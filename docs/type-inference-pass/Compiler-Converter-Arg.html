<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Compiler.Converter.Arg</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Compiler.Converter.Arg.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">haskellToCoqCompiler-0.1.0.0: A Haskell to Coq compiler.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Compiler.Converter.Arg</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains functions for converting function, constructor and
   type arguments from Haskell to Coq.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:convertTypeVarDecls">convertTypeVarDecls</a> :: Explicitness -&gt; [<a href="Compiler-Haskell-AST.html#t:TypeVarDecl" title="Compiler.Haskell.AST">TypeVarDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</li><li class="src short"><a href="#v:generateTypeVarDecls">generateTypeVarDecls</a> :: Explicitness -&gt; [<a href="Compiler-Haskell-AST.html#t:TypeVarIdent" title="Compiler.Haskell.AST">TypeVarIdent</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</li><li class="src short"><a href="#v:generateTypeVarDecls-39-">generateTypeVarDecls'</a> :: Explicitness -&gt; [<a href="Compiler-Haskell-SrcSpan.html#t:SrcSpan" title="Compiler.Haskell.SrcSpan">SrcSpan</a>] -&gt; [<a href="Compiler-Haskell-AST.html#t:TypeVarIdent" title="Compiler.Haskell.AST">TypeVarIdent</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</li><li class="src short"><a href="#v:convertArgs">convertArgs</a> :: [<a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a>] -&gt; [<a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a>] -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</li><li class="src short"><a href="#v:convertInferredArg">convertInferredArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:convertTypedArg">convertTypedArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:convertDecArg">convertDecArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:convertArg">convertArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:convertPureArg">convertPureArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:convertArg-39-">convertArg'</a> :: <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:generateArgBinder">generateArgBinder</a> :: Qualid -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder</li><li class="src short"><a href="#v:convertAnonymousArg">convertAnonymousArg</a> :: <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> (Qualid, Binder)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:convertTypeVarDecls" class="def">convertTypeVarDecls</a> <a href="src/Compiler.Converter.Arg.html#convertTypeVarDecls" class="link">Source</a> <a href="#v:convertTypeVarDecls" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Explicitness</td><td class="doc"><p>Whether to generate an explicit or implit binder.</p></td></tr><tr><td class="src">-&gt; [<a href="Compiler-Haskell-AST.html#t:TypeVarDecl" title="Compiler.Haskell.AST">TypeVarDecl</a>]</td><td class="doc"><p>The type variable declarations.</p></td></tr><tr><td class="src">-&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Converts the declarations of type variables in the head of a data type or
   type synonym declaration to a Coq binder for a set of explicit or implicit
   type arguments.</p><p>E.g. the declaration of the type variable <code>a</code> in <code>data D a = ...</code> is
   translated to the binder <code>(a : Type)</code>. If there are multiple type variable
   declarations as in <code>data D a b = ...</code> they are grouped into a single
   binder <code>(a b : Type)</code> because we assume all Haskell type variables to be
   of kind <code>*</code>.</p><p>The first argument controlls whether the generated binders are explicit
   (e.g. <code>(a : Type)</code>) or implicit (e.g. <code>{a : Type}</code>).</p></div></div><div class="top"><p class="src"><a id="v:generateTypeVarDecls" class="def">generateTypeVarDecls</a> <a href="src/Compiler.Converter.Arg.html#generateTypeVarDecls" class="link">Source</a> <a href="#v:generateTypeVarDecls" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Explicitness</td><td class="doc"><p>Whether to generate an explicit or implit binder.</p></td></tr><tr><td class="src">-&gt; [<a href="Compiler-Haskell-AST.html#t:TypeVarIdent" title="Compiler.Haskell.AST">TypeVarIdent</a>]</td><td class="doc"><p>The names of the type variables to declare.</p></td></tr><tr><td class="src">-&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Generates explicit or implicit Coq binders for the type variables with
   the given names that are either declared in the head of a data type or
   type synonym declaration or occur in the type signature of a function.</p><p>The first argument controlls whether the generated binders are explicit
   (e.g. <code>(a : Type)</code>) or implicit (e.g. <code>{a : Type}</code>).</p></div></div><div class="top"><p class="src"><a id="v:generateTypeVarDecls-39-" class="def">generateTypeVarDecls'</a> <a href="src/Compiler.Converter.Arg.html#generateTypeVarDecls%27" class="link">Source</a> <a href="#v:generateTypeVarDecls-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Explicitness</td><td class="doc"><p>Whether to generate an explicit or implit binder.</p></td></tr><tr><td class="src">-&gt; [<a href="Compiler-Haskell-SrcSpan.html#t:SrcSpan" title="Compiler.Haskell.SrcSpan">SrcSpan</a>]</td><td class="doc"><p>The location of the type variable declarations.</p></td></tr><tr><td class="src">-&gt; [<a href="Compiler-Haskell-AST.html#t:TypeVarIdent" title="Compiler.Haskell.AST">TypeVarIdent</a>]</td><td class="doc"><p>The names of the type variables to declare.</p></td></tr><tr><td class="src">-&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Compiler-Converter-Arg.html#v:generateTypeVarDecls" title="Compiler.Converter.Arg">generateTypeVarDecls</a></code> but also accepts the location of the
   type variables (for error reporting purposes).</p></div></div><div class="top"><p class="src"><a id="v:convertArgs" class="def">convertArgs</a> <a href="src/Compiler.Converter.Arg.html#convertArgs" class="link">Source</a> <a href="#v:convertArgs" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a>]</td><td class="doc"><p>The function arguments.</p></td></tr><tr><td class="src">-&gt; [<a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a>]</td><td class="doc"><p>The types of the function arguments.</p></td></tr><tr><td class="src">-&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>The position of the decreasing argument.</p></td></tr><tr><td class="src">-&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Binder]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Converts the arguments (variable patterns) of a potentially recursive
   function with the given types to explicit Coq binders.</p><p>If the type of an argument is not known, it's type will be inferred by
   Coq.</p><p>If the function is recursive, its decreasing argument (given index),
   is not lifted.</p></div></div><div class="top"><p class="src"><a id="v:convertInferredArg" class="def">convertInferredArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#convertInferredArg" class="link">Source</a> <a href="#v:convertInferredArg" class="selflink">#</a></p><div class="doc"><p>Converts the argument of a function (a variable pattern) to an explicit
   Coq binder whose type is inferred by Coq.</p></div></div><div class="top"><p class="src"><a id="v:convertTypedArg" class="def">convertTypedArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#convertTypedArg" class="link">Source</a> <a href="#v:convertTypedArg" class="selflink">#</a></p><div class="doc"><p>Converts the argument of a function (a variable pattern) with the given
   type to an explicit Coq binder.</p></div></div><div class="top"><p class="src"><a id="v:convertDecArg" class="def">convertDecArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#convertDecArg" class="link">Source</a> <a href="#v:convertDecArg" class="selflink">#</a></p><div class="doc"><p>Convert the decreasing argument (variable pattern) if a recursive function
   with the given type to an explicit Coq binder.</p><p>In contrast to a regular typed argument (see <code><a href="Compiler-Converter-Arg.html#v:convertTypedArg" title="Compiler.Converter.Arg">convertTypedArg</a></code>), the
   decreasing argument is not lifted to the <code>Free</code> monad.
   It is also registered as a non-monadic value.</p></div></div><div class="top"><p class="src"><a id="v:convertArg" class="def">convertArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#convertArg" class="link">Source</a> <a href="#v:convertArg" class="selflink">#</a></p><div class="doc"><p>Converts the argument of a function (a variable pattern) to an explicit
   Coq binder.</p></div></div><div class="top"><p class="src"><a id="v:convertPureArg" class="def">convertPureArg</a> :: <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#convertPureArg" class="link">Source</a> <a href="#v:convertPureArg" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Compiler-Converter-Arg.html#v:convertArg" title="Compiler.Converter.Arg">convertArg</a></code> but marks the variable as non-monadic.</p></div></div><div class="top"><p class="src"><a id="v:convertArg-39-" class="def">convertArg'</a> :: <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Compiler-Haskell-AST.html#t:VarPat" title="Compiler.Haskell.AST">VarPat</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#convertArg%27" class="link">Source</a> <a href="#v:convertArg-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Compiler-Converter-Arg.html#v:convertArg" title="Compiler.Converter.Arg">convertArg</a></code> but the first argument indicates whether the varibale
   has been lifted to the free monad or not (<code>True</code> for pure values and
   <code>False</code> for lifted values).</p></div></div><div class="top"><p class="src"><a id="v:generateArgBinder" class="def">generateArgBinder</a> :: Qualid -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> Term -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Binder <a href="src/Compiler.Converter.Arg.html#generateArgBinder" class="link">Source</a> <a href="#v:generateArgBinder" class="selflink">#</a></p><div class="doc"><p>Generates an explicit Coq binder for a function argument with the given
   name and optional Coq type.</p><p>If no type is provided, it will be inferred by Coq.</p></div></div><div class="top"><p class="src"><a id="v:convertAnonymousArg" class="def">convertAnonymousArg</a> :: <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> (Qualid, Binder) <a href="src/Compiler.Converter.Arg.html#convertAnonymousArg" class="link">Source</a> <a href="#v:convertAnonymousArg" class="selflink">#</a></p><div class="doc"><p>Converts the argument of an artifically generated function to an explicit
   Coq binder. A fresh Coq identifier is selected for the argument
   and returned together with the binder.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>