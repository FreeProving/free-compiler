\section{Translation of Function Declarations} \label{sec:translation:func-decl}
In this final section of the chapter we will cover the translation of the eponymous component for functional programming languages: function declarations.

Just as with type declarations the order of function declarations matters in Coq as well.
Thus, we have to perform a dependency analysis again.
Although the basic principles of the dependency analysis still apply, adding support for recursive and mutually recursive functions is more involved this time.
This is because Coq strictly distinguishes recursive and non-recursive function declarations.
Therefore, it is not sufficient to simply concatenate generated sentences.
Instead we have to apply a completely different translation scheme to recursive function declarations.
For this reason, we will focus on non-recursive function declarations first.
The translation of recursive functions is covered in the second half of this section.

\subsection{Non-Recursive Functions}
In \autoref{sec:translation:type-decl} we have already seen function declarations in Coq on the example of smart constructors.
In order to recall the basic structure of such function declarations, consider the following implementation of boolean negation without monadic lifting.
\begin{minted}{coq}
  Definition not (b : bool) : bool :=
    match b with
    | true  => false
    | false => true
    end.
\end{minted}
As we can see, Coq's function declarations are parameterized \coq{Definition} sentences.
Unlike in Haskell, there are not multiple rules and pattern matching is performed explicitly on the right hand side using \coq{match} expressions.
The return type of the function as well as the types of its arguments are annotated inside the declaration itself.
Due to our assumptions, i.e. that there is only one rule and the parameters are variable patterns, all Haskell function declarations we are concerned with already look remarkably similar to the \coq{Definition} sentences that we need to generate.
\begin{minted}{haskell}
  @$f$@ :: @$\tau$@
  @$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@
\end{minted}
The main difference here is that the type signature is independent of the actual function declaration.
If we had a type signature of the form \haskell{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@}, we could apply the translation proposed in \autoref{fig:translation:func-decl:non-rec} directly.
Note that we implicitly apply the optimization by \cite{Abel:2005} again, i.e.
the type of the converted function is not $\toCoq{(\tau_1 \rightarrow \ldots \rightarrow \tau_n \rightarrow \tau)}$ but $\toCoq{\tau_1} \rightarrow \ldots \rightarrow \toCoq{\tau_n} \rightarrow \toCoq{\tau}$.

\begin{figure}[H]
  \[
    \toCoq{\left(
      \begin{array}{l}
        \haskellM{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@} \\
        \haskellM{@$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@}
      \end{array}
    \right)}
    = \begin{array}{ll}
        \coqM{Definition @$f'$@}
          &\coqM{(@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)}     \\
          &\coqM{{@$\alpha_1$@ @$\ldots$@ @$\alpha_m$@ : Type}}           \\
          &\coqM{(@$x_1$@ : @$\toCoqX{\tau_1}$@) @$\ldots$@ (@$x_n$@ : @$\toCoqX{\tau_n}$@)}                                           \\
          &\coqM{: @$\toCoqX{\tau}$@}                                     \\
          &\coqM{:= @$\toCoqX{e}$@.}                                      \\
      \end{array}
  \]
  \caption{
    Translation rule for a $n$-ary polymorphic function declaration with $m$ type variables.
    The types $\tau_1$ through $\tau_n$ are the types of the variables $x_1$ through $x_n$ respectively.
  }
  \label{fig:translation:func-decl:non-rec}
\end{figure}

However, in general the type signature does not necessarily have that format.
This is because the type signature could contain type synonyms.
Consider for example the following function declaration.
\begin{minted}{haskell}
  type Predicate a = a -> Bool

  nonZero :: Predicate Integer
  nonZero n = n /= 0
\end{minted}
To determine the type of \haskell{n} as well as the return type of \haskell{nonZero} we need to expand the type synonym \haskell{Predicate Integer}.
Not all type synonyms need to be expanded though.
Our current approach suffices to determine the argument and return types the following two functions.
\begin{minted}{haskell}
  testZero :: Predicate Integer -> Bool
  testZero p = p 0

  greaterThan :: Integer -> Predicate Integer
  greaterThan n = (> n)
\end{minted}

The rule shown in \autoref{fig:translation:func-decl:non-rec:expansion} expands only those type synonyms that need to be expanded in order to determine the type of an argument.
In the example above, it would expand the type of \haskell{nonZero} to \haskell{Integer -> Bool} but leaves the type of both \haskell{testZero} and \haskell{greaterThan} unchanged.

\begin{figure}[H]
  \begin{align*}
    \toCoq{\left(
      \begin{array}{l}
        \haskellM{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_i$@ -> @$S$@ @$\kappa_1$@ @$\ldots$@ @$\kappa_m$@} \\
        \haskellM{@$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@}
      \end{array}
    \right)}
    = \toCoq{\left(
      \begin{array}{l}
        \haskellM{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_i$@ -> @$\sigma(\kappa)$@} \\
        \haskellM{@$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@}
      \end{array}
    \right)}
    &&\forall i < n
  \end{align*}
  \caption{
    A demand driven approach to the expansion of type synonyms in $n$-ary function declarations.
    We assume that there is type synonym declaration \haskell{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_m$@ = @$\kappa$@}.
    For the expansion of $S$ we apply the substitution $\sigma = \{\, \alpha_1 \mapsto \kappa_1, \ldots, \alpha_m \mapsto \kappa_m \,\}$.
  }
  \label{fig:translation:func-decl:non-rec:expansion}
\end{figure}

\subsection{Recursive Functions}
If we tried to apply the translation rule for non-recursive function declarations to the declaration of a recursive function like \haskell{append} (as defined in the listing below), Coq would complain that there is no such function when it encounters the recursive call to \haskell{append}.
\begin{minted}{haskell}
  append :: [a] -> [a] -> [a]
  append xs ys = case xs of
    []      -> ys
    x : xs' -> x : append xs' ys
\end{minted}
This is because \coq{Definition} sentences are not allowed to reference themselves in Coq.
If they were allowed to do so, it would be possible to define a non-terminating function.
The following is allowed in Haskell for example.
\begin{minted}{haskell}
  loop :: a
  loop = loop
\end{minted}
Similar to \haskell{undefined}, \haskell{loop} is a polymorphic value.
In much the same way as shown for \haskell{undefined} in \autoref{sec:translation:expr:errors}, \haskell{loop} could therefore be used to proof arbitrary propositions when translated to Coq.
Nevertheless, recursion is an important aspect of functional programming languages and most recursive functions also terminate eventually.
In order to still allow recursion, Coq needs to ensure that recursive functions terminate on all inputs.
To indicate that this check needs to be performed by Coq, the user has to explicitly annotate a recursive function as such.
Instead of a \coq{Definition} sentence, a \coq{Fixpoint} sentence is used in this case.
The following non-lifted implementation of \coq{append} would be accepted by Coq for example.
\begin{minted}{coq}
  Fixpoint append {a : Type} (xs : list a) (ys : list a) : list a
    := match xs with
       | nil        => ys
       | cons x xs' => cons x (append xs' ys)
       end.
\end{minted}
To check that functions like \coq{append} actually terminate, Coq carries out a syntactic analysis of the \coq{Fixpoint} sentence.
Namely Coq must be able to recognize that the function \textit{decreases} on one of its arguments.
We say that a \coq{Fixpoint} sentence \coq{Fixpoint @$f$@ (@$x_1$@ : @$\tau_1$@) @$\ldots$@ (@$x_1$@ : @$\tau_1$@) : @$\tau$@ := @$e$@.} decreases on $x_i$ if the $i$-th argument of every recursive call to $f$ in $e$ is \textit{structurally smaller} than the original argument $x_i$ \cite[p.~111]{CoqDevTeam:2018}.
One source of structurally smaller smaller terms is pattern matching.
If pattern matching is performed on the decreasing argument or a structurally smaller term, the variables in the patterns are structurally smaller than the decreasing argument themselves.
In the example above, \coq{append} is decreasing on its first explicit argument, i.e. \coq{xs}.
This is because in the only recursive call \coq{append xs' ys} the first argument, i.e. \coq{xs'}, is bound to a subterm of \coq{xs} by the means of pattern matching.

Although Coq's termination checker uses a more sophisticated ruleset to determine whether a term is structurally smaller than another, it rejects the lifted version of \coq{append} that the translation rule in \autoref{fig:translation:func-decl:non-rec} would produce if we simply swapped \coq{Definition} for \coq{Fixpoint}.
\begin{minted}{coq}
  Fixpoint append (@$\Shape$@ : Type) (@$Pos$@ : @$\Shape$@ -> Type) {a b : Type}
                  (f : @$\toCoq{(a \rightarrow b)}$@) (xs : @$\toCoq{[a]}$@) : @$\toCoq{[b]}$@
    := xs >>= (fun xs_0 =>
         match xs_0 with
         | nil        => ys
         | cons x xs' => Cons @$\Shape$@ @$Pos$@ x (append xs' ys)
         end).
\end{minted}
This is because this time \coq{xs'} is not a direct subterm of \coq{xs} but of \coq{xs_0}.
That the \coq{>>=} operator is implemented in such a way that \coq{xs_0} is always bound to a subterm of \coq{xs} is not checked by Coq.
