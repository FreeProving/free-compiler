\section{Translation of Type Declarations} \label{sec:translation:type-decl}
This section covers the translation of type synonyms and data type declarations.
Because the order of declarations matters in Coq, special care needs to be taken to translate only declarations whose dependencies were translated already.
For simplicity we will first consider only independent declarations and extend the resulting translation rules to support mutually dependent declarations at the end of this section.

\subsection{Type synonym declarations}
Type synonyms can be used in Haskell to give a name to a more complex type expression.
Similarly we can use a \coq{Definition}-sentence to to assign a name to a term in Coq.
Because Coq does not distinguish types and terms, declarations of type synonyms can be simply translated to \coq{Definition}-sentences as shown in \autoref{fig:translation:type-decl:type-syn}.

\begin{figure}[H]
  \begin{align*}
    \toCoq{(
      \haskellM{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@}
     )}
    = \coqM{Definition @$S'$@} &\;\coqM{(Shape : Type) (Pos : Shape -> Type)           } \\
                               &\;\coqM{(@$\alpha_1'$@ @$\ldots$@ @$\alpha_n'$@ : Type)} \\
                               &\;\coqM{: Type                                         } \\
                               &\;\coqM{:= @${\tau}^{*}$@.                             } % FIXME \toCoqT does not work in this situation.
  \end{align*}
  \caption{Translation rule for $n$-ary polymorphic type synonym declarations.}
  \label{fig:translation:type-decl:type-syn}
\end{figure}

The parameters $Shape$ and $Pos$ have to be added such that the translated type can use the free monad or other data types.
For example the following type synonym
\begin{minted}{haskell}
  type Queue a = [a]
\end{minted}
needs $Shape$ and $Pos$ when translated to to Coq because they need to be passed to \coq{List}.
\begin{minted}{coq}
  Definition Queue (Shape : Type) (Pos : Shape -> Type) (a : Type) : Type
                   := List Shape Pos a.
\end{minted}

On the right hand side of the \coq{Definition}-sentence in \autoref{fig:translation:type-decl:type-syn} the $\toCoqT{}$ translation is applied instead of $\toCoq{}$.
This is because we desire the expansion of type synonyms in Haskell and Coq to be compatible with respect to the $\toCoq{}$ translation.
To convince ourselves that the translation rule above fulfills this property lets denote the expansion of type synonyms in Haskell and Coq with $\beta_H$ and $\beta_C$ respectively and show that for all type synonyms \haskell{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@} and type expressions $\tau_1, \ldots \tau_n$ the following holds true.
\[
  \toCoq{\beta_H(S\;\tau_1\;\ldots\;\tau_n)}
  = \beta_C(\toCoq{(S\;\tau_1\;\ldots\;\tau_n)})
\]

For the instantiation of $S$ and $S'$ we first define substitutions $\sigma$ and $\sigma'$.
\begin{align*}
  \sigma &\coloneqq \{\, \alpha_1 \mapsto \tau_1, \ldots, \alpha_n \mapsto \tau_n \,\} \\
  \sigma' &\coloneqq \{\, \alpha_1' \mapsto \toCoqT{\tau_1}, \ldots, \alpha_n' \mapsto \toCoqT{\tau_n} \,\}
\end{align*}
Now we can proof the proposition by applying the translation rules for types presented in the previous section.

\begin{align*}
  \toCoq{\beta_H(S\;\tau_1\;\ldots\;\tau_n)}
    &= \toCoq{\sigma(\tau)}
       \tag{expansion of $S$} \\
    &= \Free{\toCoqT{\sigma(\tau)}}
       \tag{\autoref{eqn:translation:type}} \\
    &= \Free{\sigma'(\toCoqT{\tau})}
       \tag{$\star$} \\
    &= \beta_C{(\Free{(S'\;Shape\;Pos\;\toCoqT{\tau_1}\;\ldots\;\toCoqT{\tau_n})})}
       \tag{undo expansion of $S'$} \\
    &= \beta_C{(\Free{\toCoqT{(S\;\tau_1\;\ldots\;\tau_n)}})}
       \tag{\autoref{eqn:translation:type:application} and \ref{eqn:translation:type:constructor}} \\
    &= \beta_C(\toCoq{(S\;\tau_1\;\ldots\;\tau_n)})
       \tag{\autoref{eqn:translation:type}}
\end{align*}
\qed

The equation marked with $(\star)$ follows from the following property of $\sigma$ and $\sigma'$.
\begin{align*}
  \toCoqT{\sigma(\alpha_i)} = \toCoqT{\tau_i}
                            = \sigma'(\alpha_i')
                            = \sigma'(\toCoqT{\alpha_i})
  &&\forall i \in \{\, 1, \ldots, n \,\}
\end{align*}
We assume without a proof that this property holds for the extensions of $\sigma$ and $\sigma'$ as well.

\subsection{Data Types}
\subsection{Handling Mutually Dependent Type Declarations}
