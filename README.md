# Free Compiler

<!-- Logo -->
<img src="https://raw.githubusercontent.com/FreeProving/free-compiler/master/img/logo.png" width="350" style="max-width: 100%" align="right" alt="Logo" />

<!-- Badges -->
![CI Pipeline](https://github.com/FreeProving/free-compiler/workflows/CI%20Pipeline/badge.svg)

<!-- Short description -->
A compiler for the monadic translation of Haskell programs to Coq that uses the `Free` monad as presented by [Dylus et al.][paper/DylusEtAl2018] to model partiality and other ambient effects.

## Table of Contents

1. [Documentation](#documentation)
2. [Getting Started](#getting-started)
    - [Required Software](#required-software)
    - [Base Library](#base-library)
    - [Installation](#installation)
    - [Running without Installation](#running-without-installation)
3. [Usage](#usage)
    - [Command line options](#command-line-options)
      + [`--output=DIR`, `-o DIR`](#--outputdir--o-dir)
      + [`--import=DIR`, `-i DIR`](#--importdir--i-dir)
      + [`--base-library=DIR`, `-b DIR`](#--base-librarydir--b-dir)
      + [`--no-coq-project`](#--no-coq-project)
    - [Proving properties](#proving-properties)
    - [Experimental Features](#experimental-features)
      + [Pattern-Matching Compilation](#pattern-matching-compilation)
4. [Get Involved](#get-involved)
5. [License](#license)

## Documentation

This compiler was originally developed as part of a [bachelor's thesis][thesis/Andresen2019].
The compiler has been extended with additional features and its architecture changed compared to the [version presented in the thesis][tag/v0.1.0.0] but the explanation of the monadic translation in the thesis is still up to date.

The compiler's source code is documented using [Haddock][software/haddock].
The documentation is automatically build by our CI pipeline and published [here][gh-pages/haddock].

Additional documentation can be found in the [`doc/`][doc] directory.

## Getting Started

### Required Software

The Free Compiler is written in Haskell and uses Cabal to manage its dependencies.
To build the compiler, the GHC and Cabal are required.
To use the Coq code generated by our compiler, the Coq proof assistant must be installed.
The compiler has been tested with the following software versions on a Debian based operating system.

 - [GHC][software/ghc], version 8.6.5
 - [Cabal][software/cabal], version 2.4.1.0
 - [Coq][software/coq], versions 8.8 through 8.11

### Base Library

In order to use the base library, the Coq files in the base library need to be compiled first.
Make sure to compile the base library **before installing** the compiler.
We provide a shell script for the compilation of Coq files.
To compile the base library with that shell script, run the following command in the root directory of the compiler.

```bash
./tool/compile-coq.sh base
```

> **Note:** If you add or remove files from the `base` library (or any other directory that contains Coq code that you wish to compile using the script above), the automatically generated Makefile needs to be updated.
> For this purpose the script provides the command line option `--recompile`.
>
> ```bash
> ./tool/compile-coq.sh --recompile base
> ```

### Installation

First, make sure that the Cabal package lists are up to date  by running the following command.

```bash
cabal new-update
```

To build and install the compiler and its dependencies, change into the compiler’s root directory and run the following command.

```bash
cabal new-install freec
```

The command above copies the base library and the compiler’s executable to Cabal’s installation directory and creates a symbolic link to the executable in
`~/.cabal/bin`.
To test whether the installation was successful, make sure that `~/.cabal/bin` is in your `PATH` environment variable and run the following command.

```bash
freec --help
```

### Running without Installation

If you want to run the compiler without installing it on your machine (i.e., for debugging purposes), execute the following command in the root directory of the compiler instead of the `freec` command.

```bash
cabal new-run freec -- [options...] <input-files...>
```

The two dashes are needed to separate the arguments to pass to the compiler from Cabal’s arguments.
Alternatively, you can use the `./tool/run.sh` bash script.

```bash
./tool/run.sh [options...] <input-files...>
```

Besides invoking Cabal and forwarding its command line arguments to the compiler, the script also sets the `-Wwarn` flag of the GHC automatically.
This overwrites the `-Werror` flag of the GHC that is set in addition to the `-Wall` flag by default.
The default configuration causes compilation to fail when there are unhandled warnings in the source code.
As a result, the CI pipeline rejects commits that introduce such warnings.
While it is important that no warnings are reported in a production setting, fatal warnings can be disrupting when debugging.
Thus, we recommend using the `./tool/run.sh` script during development and running `./tool/full-test.sh` (which uses the default settings) once before pushing your local changes.

## Usage

To compile a Haskell module, pass the file name of the module to `freec`.
For example, to compile the examples from the `Data.List` module run the the following command.

```bash
freec ./example/Data/List.hs
```

In order to compile multiple modules which `import` on each other, multiple file names can be passed as an argument.

```bash
freec ./example/Data/List.hs ./example/Data/Function.hs
```

Both commands above print the generated Coq code directly to the console.
See the `--output` option below for how to write the generated Coq code into files instead.

### Command line options

#### `--output=DIR`, `-o DIR`

By default generated Coq code is printed to the console.
To write to a file instead, specify an output directory using the `--output` option.
A file `X/Y/Z.v` is placed into the output directory for every module `X.Y.Z` that is compiled.
For example, the following command creates the files `example/generated/Data/List.v` and `example/generated/Data/Function.v`

```bash
freec -o ./example/generated ./example/Data/*.hs
```

In addition to the `.v` files `.json` files are generated as well.
The JSON files contain the [module interfaces][doc/ModuleInterfaceFileFormat.md] for the translated modules.
The module interface files can be used to import modules that have been translated already without specifying them on the command line.
For example, if `Data.List` and `Data.Functor` have been translated already, the `ListFunctor` example can be compiled on its own since its imports can be served from the module interface files.

```bash
freec -o ./example/generated ./example/ListFunctor.hs
```

#### `--import=DIR`, `-i DIR`

The compiler searches for module interfaces in the output directory (see `--output` option) and the current working directory by default.
If you want to compile modules that import files that have been written to a different output directory, you can use the `--import` command line option to specify additional paths to search for modules interfaces in.
For example, if `Data.List` and `Data.Functor` have been translated already and their output has been written to `./examples/generated`, you can translate `ListFunctor` and print its output to the console as follows.

```bash
freec -i ./example/generated ./example/ListFunctor.hs
```

To add multiple import paths just add one `--import` option for each path.
There can be arbitrarily many import paths and the `--import` and `--output` options can be mixed.

```bash
./tool/run.sh -o <dir0> -i <dir1> -i <dir2> … <input-files...>
```

In the example above, the compiler would search for a module interface file first in the current working directory and then in the directories in the order they have been specified on the command line (i.e., first `.`, then `<dir0>`, then `<dir1>`, then `<dir2>` and so on).

#### `--base-library=DIR`, `-b DIR`

Predefined data types and operations are not build directly into the compiler but part of the *base library* that accompanies the compiler.
The compiler uses the same mechanism that is used to load module dependencies to load modules from the base library, i.e., module interface files.
In contrast to automatically generated module interface files, the base library does not use the JSON file format but TOML since the module interfaces of the base library are maintained manually and TOML is a more user friendly format.
The module interface file format is documented in [`doc/ModuleInterfaceFileFormat.md`][doc/ModuleInterfaceFileFormat.md].

In order for the compiler to locate the `Prelude.toml` module interface file, the location of the base library must be known.
If the compiler is installed as described above or executed using `cabal`, it will usually be able to locate the base library automatically.
Otherwise, it may be necessary to tell the compiler where the base library can be found using the `--base-library` option.

```bash
freec -b ./base ./example/Data/List.hs
```

#### `--no-coq-project`

When an output directory has been specified using the `--output` option and the output directory does not contain a `_CoqProject` file, it is created automatically.
The `_CoqProject` file tells Coq where to find the compiler’s base library and assigns the logical name `Generated` to the directory that contains the generated Coq code.
The file has the following format where `<base-library>` is the path to the base library (see `--base-library` command line option).

```
-R <base-library> Base
-R . Generated
```

The logical names `Base` and `Generated` are used in the generated import sentences.
For example, a generated file could contain the following lines.

```coq
From Base Require Import Prelude.
From Generated Require Export Data.List.
```

You can safely edit the `_CoqProject` file or supply your own configuration as long as Coq is still able to locate the `.v` files under their logical prefixes.
The compiler will not overwrite your changes since the `_CoqProject` file is only written to if it does not exist.

If you don't want the `_CoqProject` file to be generated at all, you can add the `--no-coq-project` flag.
However, note that you may not be able to compile the generated Coq code if the `_CoqProject` file is missing.

### Proving properties

The main goal for the translation of Haskell code to Coq is to prove properties of the Haskell program in Coq.
In order to do so, we have to formulate the properties to prove first.
Due to the overhead involved with our translation, stating propositions in Coq directly is very tedious.
Therefore, we provide a mechanism for deriving Coq properties from QuickCheck properties.
This allows us to state the proposition in Haskell instead of Coq.

Consult [`doc/ProvingQuickCheckProperties.md`][doc/ProvingQuickCheckProperties.md] for more details and examples.

### Experimental Features

#### Pattern-Matching Compilation

By default the compiler does support a limited subset of the Haskell programming language only.
There is experimental support to relax some of those restrictions.
Add the `--transform-pattern-matching` command line option to automatically transform the input modules using a [pattern matching compiler library][package/haskell-src-transformations] for [`haskell-src-exts`][package/haskell-src-exts] before they are translated by our compiler.
For example, the `PatternMatching` example can be translated as follows.

```bash
freec --transform-pattern-matching ./example/PatternMatching.hs
```

Consult [`doc/ExperimentalFeatures/PatternMatchingCompilation.md`][doc/ExperimentalFeatures/PatternMatchingCompilation.md] for more details and examples.

## Get Involved

Feature requests, enhancement proposals, bug reports, pull requests and all other contributions are welcome!  
Have a look at our [contribution guidelines][freec/CONTRIBUTING] for more information on how to contribute.

## License

The Free Compiler is licensed under The 3-Clause BSD License.  
See the [LICENSE][freec/LICENSE] file for details.

[doc]:
  https://github.com/FreeProving/free-compiler/tree/master/doc
  "Free Compiler Documentation"
[doc/ModuleInterfaceFileFormat.md]:
  https://github.com/FreeProving/free-compiler/blob/master/doc/ModuleInterfaceFileFormat.md
  "Free Compiler Documentation — Module Interface File Format"
[doc/ExperimentalFeatures/PatternMatchingCompilation.md]:
  https://github.com/FreeProving/free-compiler/blob/master/doc/ExperimentalFeatures/PatternMatchingCompilation.md
  "Free Compiler Documentation — Pattern Matching Compilation"
[doc/ProvingQuickCheckProperties.md]:
  https://github.com/FreeProving/free-compiler/blob/master/doc/ProvingQuickCheckProperties.md
  "Free Compiler Documentation — Proving QuickCheck Properties"

[freec/CONTRIBUTING]:
  https://github.com/FreeProving/free-compiler/blob/master/CONTRIBUTING.md
  "Free Compiler — Contribution Guidelines"
[freec/LICENSE]:
  https://github.com/FreeProving/free-compiler/blob/master/LICENSE
  "Free Compiler — The 3-Clause BSD License"

[gh-pages/haddock]:
  https://freeproving.github.io/free-compiler/docs/master
  "Free Compiler Haddock Documentation"

[package/haskell-src-transformations]:
  https://github.com/FreeProving/haskell-src-transformations
  "haskell-src-transformations"
[package/haskell-src-exts]:
  https://hackage.haskell.org/package/haskell-src-exts
  "haskell-src-exts"

[paper/DylusEtAl2018]:
  https://arxiv.org/abs/1805.08059
  "One Monad to Prove Them All"

[software/haddock]:
  https://www.haskell.org/haddock/
  "Haddock"
[software/ghc]:     
  https://www.haskell.org/ghc/
  "The Glasgow Haskell Compiler"
[software/cabal]:
  https://www.haskell.org/cabal/
  "Common Architecture for Building Applications and Libraries"
[software/coq]:
  https://coq.inria.fr/download
  "The Coq Proof Assistant"

[tag/v0.1.0.0]:
  https://github.com/FreeProving/free-compiler/tree/v0.1.0.0
  "Free Compiler v0.1.0.0"

[thesis/Andresen2019]:
  https://freeproving.github.io/free-compiler/thesis/Andresen2019.pdf
  "Implementation of a Monadic Translation of Haskell Code to Coq"
