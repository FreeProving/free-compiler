\section{Conversion to Coq} \label{sec:implementation:coq-ast}
For the conversion to Coq, we need a representation of Coq programs in Haskell.
Just like we used an external package for parsing Haskell source code, we are also reusing an existing Coq AST and pretty printer.
The pretty printer is a component for converting the Coq AST to a textual representation.
Unlike \texttt{haskell-src-exts}, there is currently no Coq package on Hackage.
However, the developers of \texttt{hs-to-coq} implemented a Coq AST and pretty printer already.
Thus, we forked their GitHub repository\footnote{\url{https://github.com/antalsz/hs-to-coq}} and deleted everything but the Coq language definitions.
We refer to the remaining code in the forked repository\footnote{\url{https://github.com/just95/language-coq}} as the \texttt{language-coq} package.
Since \texttt{hs-to-coq} is released under the MIT license agreement, it is possible to publish the package to Hackage in the future.

With our simplified AST and the \texttt{language-coq} package at hand, we can now implement the translation rules from \autoref{chp:translation} very easily.
The following two subsections provide details on how our compiler handles state and renames identifiers in the conversion process.

\subsection{Environment} \label{sec:implementation:conversion:environment}
During the conversion to Coq, we have to retain a lot of information about the program that we are translating.
Amongst others, we have to remember:
\begin{itemize}
  \item the names we have assigned to the generated Coq sentences, such that we can translate references to them correctly,
  \item the arity of defined functions, such that we can perform the right number of $\eta$-conversions to partial applications,
  \item which functions are partial, such that we can pass the \coq{Partial} instance to them and
  \item which variables have been lifted to the \coq{Free} monad and which haven't.
\end{itemize}
Since it would be infeasible, to pass all this information as individual parameters, we encapsulate the entire state of the compiler in a single data type \haskell{Environment}.
Additionally, some conversion operations have an effect on the compiler's environment.
For example, when translating a function declaration, the function becomes available to subsequently translated function declarations, i.e., an entry must be added to the environment for the declared function.
Therefore, every function of the compiler would not only have to be given a parameter of type \haskell{Environemnt} but can also return an \haskell{Environment} in addition to the actual result.
In consequence, the approach of passing the environment explicitly still causes a lot of overhead.
We have solved this issue by using the \haskell{State} monad.
The \haskell{State} monad allows a state~--~in our case, the \haskell{Environment}~--~to be passed around and manipulated implicitly throughout the computation.

\subsection{Renaming Identifiers} \label{sec:implementation:conversion:renaming}
As mentioned in \autoref{sec:preliminaries:notation:renaming}, identifiers may have to be renamed during the translation to Coq.
For example, the Coq Reference Manual lists the following reserved keywords which cannot be used as identifiers in Coq \cite[p.~24]{CoqDevTeam:2018}.
\begin{minted}{coq}
  _ as at cofix else end exists exists2 fix for
  forall fun if IF in let match mod Prop return
  Set then Type using where with
\end{minted}
Furthermore, words used within vernacular commands, should not be used as identifiers.
For example, it is not possible to define a datatype called \haskell{Definition} in Coq, i.e., the following is invalid.
\begin{minted}{coq}
  Inductive Definition : Type := (* ... *).
  (* ==> Syntax error: [inductive_definition] expected
         after [finite_token] (in [vernac:gallina]). *)
\end{minted}
Therefore, we have assembled a list of all Coq keywords and words used within vernacular commands \cite[pp.~484-487]{CoqDevTeam:2018}.
Whenever there is a declaration whose name occurs within that list, it must be renamed as described below.

Another reason for an identifier to have to be renamed, is that there is a declaration with the same name already.
Such name conflicts can occur because~--~unlike Coq~--~Haskell has two distinct namespaces for types and values.
The following is valid in Haskell but when converted to Coq we have to rename either the type or constructor for example.
\begin{minted}{haskell}
  data Foo = Foo
\end{minted}
Therefore, we remember the names of all defined types, functions and variables in our environment.
If an identifier is translated and occurs already in the environment, it has to be renamed.
Additionally, we have to remember the namespace where the identifier has been defined.
It is an error if there are two declarations in the same namespace with the same name.
For example, it is not allowed to have two type variables with the same name.
\begin{minted}{haskell}
  data Foo a a = Foo
\end{minted}

Since we want to preserve the original identifier as good as possible, identifiers are renamed by appending a number.
The number starts with zero and is increased until the resulting identifier is available.
If the original identifier ends with a number, counting continues at that number.
Consider for example the following data type declaration.
\begin{minted}{haskell}
  data Definition exists2 = Definition exists2
\end{minted}
The identifiers that occur within this declaration need to be translated as follows.
\begin{itemize}
  \item
  The name of the type constructor is encountered first.
  As \haskell{Definition} is a vernacular command, it has to be renamed to \coq{Definition0}.

  \item
  The type variable \haskell{exists2} is a keyword and needs to be renamed as well.
  Since it ends with a number, it is renamed to \coq{exists3} instead of \coq{exists20}.

  \item
  The constructor \haskell{Definition} again needs to be renamed as it is a vernacular command.
  However, this time the identifier \coq{Definition0} is taken already.
  Therefore, the next available identifier is \coq{Definition1}.
  The capitalized version of the constructor name is used for the smart constructor.
  The actual constructor of the data type starts with a lower case letter.
  In case of \haskell{Definition}, the data constructor is called \coq{definition} in Coq and does not have to be renamed.

  \item
  In the constructor argument, \haskell{exists2} is not a declaration but a reference.
  The compiler looks up the corresponding Coq identifier for \haskell{exists2} in the environment.
  The environment contains an entry that maps the Haskell identifier \haskell{exists2} in the type namespace to the Coq identifier \coq{exists3}.
  Therefore, the type variable is translated to \coq{exists3}.
\end{itemize}
The code generated by our compiler looks as follows.
\begin{minted}{coq}
(* Data type declarations for Definition *)
Inductive Definition0 (Shape : Type) (Pos : Shape -> Type)
                      (exists3 : Type) : Type
  := definition : Free Shape Pos exists3 -> Definition0 Shape Pos exists3.

(* Arguments sentences for Definition *)
Arguments definition {Shape} {Pos} {exists3}.

(* Smart constructors for Definition *)
Definition Definition1 (Shape : Type) (Pos : Shape -> Type)
                       {exists3 : Type} (x_0 : Free Shape Pos exists3)
   : Free Shape Pos (Definition0 Shape Pos exists3) :=
  pure (definition x_0).
\end{minted}

The identifier \coq{x_0} in the smart constructor declaration is freshly generated by the compiler.
Internally fresh identifier consist of a prefix (\haskell{x} in the example above), an \texttt{@} sign and an increasing number.
As the \texttt{@} signs are not allowed inside Haskell identifiers, fresh identifiers are guaranteed to never conflict with any user-defined identifiers.
For the purpose of generating fresh identifiers, the environment contains an independent counter for each prefix.
Since the \texttt{@} sign is not allowed within Coq identifiers either, it is replaced by an underscore before renaming the identifier.
