\section{Translation of Expressions} \label{sec:translation:expr}
Starting with this section we direct our attention away from type-level language constructs.
Instead, we will have a look at the translation of expressions.
Nevertheless, we have to keep the translation rules for types in mind.
We have to do so because we wish the translation of expressions to be compatible with the translation of expressions.
In other words, when an expression $e$ of type $\tau$ is translated to Coq, the resulting term $\toCoq{e}$ must be of type $\toCoq{\tau}$.
When designing the translation rules for expressions, we have to make sure that this \textit{invariant} is preserved at all times.
\[
  \haskellM{@$e$@ :: @$\tau$@}
  \implies \coqM{@$\toCoqX{e}$@ : @$\toCoqX{\tau}$@}
  \tag{invariant}
  \label{eqn:translation:expr:invariant}
\]

\subsection{Translation of Variables} \label{sec:translation:expr:vars}
In the simplest case, the expression is just a variable $x$.
As mentioned before, when translating $x$ to Coq, we may have to rename $x$ to avoid name conflicts.
\[
  \toCoq{x} = x'
\]
If we design the translation rules that are concerned with binding variables correctly, the \ref{eqn:translation:expr:invariant} holds automatically.
For example, when we perform pattern matching on a list (as defined in the previous section) the pattern \coq{cons x xs} binds the variables \coq{x} and \coq{xs} to values of type $\toCoq{\texttt{a}}$ and $\toCoq{(\texttt{List a})}$, respectively.
However, as we will see later, there are some rare cases in which we need unlifted variables, i.e., variables of type $\toCoqT{\tau}$.
In this case, we have to manually lift $x'$ to restore the \ref{eqn:translation:expr:invariant}.
Thus, the final translation rule for variables are as shown in \autoref{fig:translation:expr:var}.

\begin{figure}[H]
  \[
    \toCoq{x} = \begin{cases}
      x'        &\text{if } x' : \toCoq{\tau} \\
      \pure{x'} &\text{if } x' : \toCoqT{\tau}
    \end{cases}
  \]
  \caption{The translation of a variable $x$ depends on the type $x'$ has been bound to in Coq.}
  \label{fig:translation:expr:var}
\end{figure}

\subsection{Translation of Function Applications} \label{sec:translation:expr:app}
In general, a function application has the form $e_1\;e_2$ in Haskell where $e_1$ is of some function type $\tau_1 \rightarrow \tau_2$ and $e_2$ is of type $\tau_1$.
The application of $e_1$ to $e_2$ yields a value of type $\tau_2$.
If we now translate both expressions to Coq, the \ref{eqn:translation:expr:invariant} guarantees us to obtain lifted values.
\begin{align*}
  \toCoq{e_1} &: \toCoq{(\tau_1 \rightarrow \tau_2)}
  \implies \toCoq{e_1} : \Free{(\toCoq{\tau_1} \rightarrow \toCoq{\tau_2})} \\
  \toCoq{e_2} &: \toCoq{\tau_1}
\end{align*}
If we had a value $f$ of type $\toCoq{\tau_1} \rightarrow \toCoq{\tau_2}$, we could apply $f$ to $\toCoq{e_2}$ to obtain a value of type $\toCoq{\tau_2}$ which would satisfy the \ref{eqn:translation:expr:invariant}.
As $\toCoq{e_1}$ is lifted to the free monad, we cannot access the contained function directly but have to use the bind operator to unwrap the function as shown in \autoref{fig:translation:expr:app}.
\begin{figure}[H]
  \[
    \toCoq{(e_1\;e_2)} = \toCoq{e_1}\;\coqM{>>= (fun @$f$@ => @$f$@ @$e_2$@)}
  \]
  \caption{General translation rule for function applications. More specific rules will be introduced for the application of constructors and defined functions below.}
  \label{fig:translation:expr:app}
\end{figure}

Usually, functions do not take just a single argument though.
For example, consider the application of a function $f$ to $n$ arguments.
\begin{align*}
  \toCoq{(f\;e_1\;\ldots\;e_n)}
    = \toCoq{f}\;&\coqM{>>= (fun @$f_1$@ => @$f_1$@}\;\toCoq{e_1}\coqM{)} \\
                 &\vdots                                                  \\
                 &\coqM{>>= (fun @$f_n$@ => @$f_n$@}\;\toCoq{e_n}\coqM{)}
\end{align*}
As this example suggests, the rule above will cause the generation of code that is long and difficult to comprehend.
Moreover, binding the intermediate results is often superfluous because we know that the partial application of a constructor or defined function will never have an effect in Haskell.
For this reason, \cite{Abel:2005} suggest an optimization that allows the generation of more readable code if a constructor or defined function is fully applied.
\begin{figure}[H]
  \begin{align*}
    \toCoq{(C\;e_1\;\ldots\;e_n)} = C'\;\Shape\;\Pos\;\toCoq{e_1}\;\ldots\;\toCoq{e_n} \\
    \toCoq{(f\;e_1\;\ldots\;e_n)} = f'\;\Shape\;\Pos\;\toCoq{e_1}\;\ldots\;\toCoq{e_n}
  \end{align*}
  \caption{Translation rule for the full application of a $n$-ary constructor $C$ or defined function $f$.}
  \label{fig:translation:expr:fun_app}
\end{figure}

We actually applied this optimization already during the generation of smart constructors.
The constructor \haskell{Just} of the \haskell{Maybe} data type has the type $a \rightarrow \texttt{Maybe}\;a$ for example.
According to the \ref{eqn:translation:expr:invariant}, the expression \haskell{Just} should now be translated to to a Coq term of type
\[
  \toCoq{(a \rightarrow \texttt{Maybe}\;a)}
    = \Free{\toCoqT{(a \rightarrow \texttt{Maybe}\;a)}}
\]
However, the smart constructor \coq{Just} has never been lifted to the free monad.
Only its argument and return types are monadic.
\begin{minted}{coq}
  Check Just.
  (* ==> Just : forall (Shape : Type) (Pos : Shape -> Type) (a : Type),
                Free Shape Pos a -> Free Shape Pos (Maybe Shape Pos a) *)
\end{minted}
Therefore, the application of \coq{Just} does not involve the bind operator as shown in \autoref{fig:translation:expr:fun_app}.
We will apply the same optimization when we translate function declarations in the final section of this chapter.

The only drawback is, that the optimization does not allow partial function applications so far.
As \cite{Abel:2005} point out, this problem can easily be solved by performing $\eta$-abstractions until all function applications are fully applied.
An individual $\eta$-abstraction transforms a function $f$ to an equivalent function by wrapping $f$ with a lambda abstraction and and passing the argument to $f$.
\[
  f \xrightarrow[\eta]{} \lambda x. f\;x
\]
The full process is depicted in \autoref{fig:translation:expr:eta}.
The right-hand side of both equations requires us to be able to convert lambda abstractions to Coq.
But before we examine the translation of lambda abstractions next, lets first look into another kind of function application: operator applications.
\begin{figure}[H]
  \begin{align*}
    \toCoq{(C\;e_1\;\ldots\;e_m)} = \toCoq{(\haskellM{\@$x_1$@ -> @$\ldots$@ \@$x_{m - n}$@ ->}\; C\;e_1\;\ldots\;e_m\;x_1\;\ldots\;x_{n - m})} \\
    \toCoq{(f\;e_1\;\ldots\;e_m)} = \toCoq{(\haskellM{\@$x_1$@ -> @$\ldots$@ \@$x_{m - n}$@ ->}\; f\;e_1\;\ldots\;e_m\;x_1\;\ldots\;x_{n - m})}
  \end{align*}
  \caption{Translation rule for the partial application of a $n$-ary constructor $C$ or defined function $f$ to $m < n$ arguments.}
  \label{fig:translation:expr:eta}
\end{figure}

Most binary operations such as \haskell{(+)} or \haskell{(==)} as well as the list constructor \haskell{(:)} are usually written in infix rather than prefix notation.
It is also possible to write custom functions in infix notation by surrounding the function name in grave accents ("backticks" or "backquotes").
For example, instead of \haskell{div @$x$@ @$y$@} one can write \haskell{@$x$@ `div` @$y$@}.
When properly used, this notation can often increase the readability of programs.
Similarly, there is a unary minus prefix operator that can be used as \textit{syntactic sugar} for the application of the \haskell{negate} function from Haskell's Prelude.
As \autoref{fig:translation:expr:op} demonstrates, the translation of operator applications is straightforward.

\begin{figure}[H]
  \begin{align*}
    \toCoq{(e_1 \circ e_2)} &= \toCoq{(\haskellM{(@$\circ$@) @$e_1$@ @$e_2$@})} \\
    \toCoq{(\haskellM{-@$e$@})} &= \toCoq{(\haskellM{negate @$e$@})}
  \end{align*}
  \caption{
    Translation rules for operator applications based on the identities listed by the Haskell Report \cite[p.~18]{Marlow:2010}.
  }
  \label{fig:translation:expr:op}
\end{figure}

However, in Haskell it is also possible to apply operators only partially.
So called \textit{sections} are written as \haskell{(@$e_1$@ @$\circ$@)} ("left section") or \haskell{(@$\circ$@ @$e_2$@)} ("right section").
A right section coincides with a regular partial application of the operator.
A left section on the other hand cannot be expressed in this way.
Therefore, we need to introduce the missing left argument in a similar way to an $\eta$-abstraction.
\begin{figure}[H]
  \begin{align*}
    \toCoq{(e_1\;\circ)}
      &= \toCoq{(\haskellM{(@$\circ$@) @$e_1$@})}                                        \\
      &\xrightarrow[\eta]{} \toCoq{(\haskellM{\@$x_2$@ -> (@$\circ$@) @$e_1$@ @$x_2$@})} \\
    \toCoq{(\circ\;e_2)}
      &= \toCoq{(\haskellM{\@$x_1$@ -> (@$\circ$@) @$x_1$@ @$e_2$@})}
  \end{align*}
  \caption{
    Translation rules for left and right sections based on the identities listed by the Haskell Report \cite[p.~19]{Marlow:2010}.
  }
  \label{fig:translation:expr:sections}
\end{figure}

\subsection{Translation of Lambda Abstractions} \label{sec:translation:expr:lambda}
Lets first consider a lambda abstraction \haskell{\@$x$@ -> @$e$@} with a single argument.
We have seen a Coq lambda abstraction on the right-hand side of \coq{>>=} in the previous subsection already.
In Coq our unary lambda abstraction could be represented by the term \coq{fun @$x'$@ => @$\toCoq{e}$@}.
However, we still need to wrap the function with the \coq{pure} constructor of the free monad to make the \ref{eqn:translation:expr:invariant} hold.
\[
  \toCoq{(\haskellM{\@$x$@ -> @$e$@})} = \coqM{pure (fun @$x'$@ => @$\toCoqX{e}$@)}
\]
If we now try to extend this rule to lambda abstractions \haskell{\@$x_1$@ @$\ldots$@ @$x_n$@ -> @$e$@} with multiple arguments, we cannot simply add more binders to the Coq function.
The following would be valid Coq, but violates our \ref{eqn:translation:expr:invariant}.
\[
  \coqM{pure (fun @$x_1'$@ @$\ldots$@ @$x_n'$@ => @$\toCoqX{e}$@)}
\]
The term above has the type
\[
  \Free{(\toCoq{\tau_1}
    \rightarrow \ldots
    \rightarrow \toCoq{\tau_n}
    \rightarrow \toCoq{\tau})}
\]
but should have the type
\[
  \Free{(\toCoq{\tau_1}
    \rightarrow \Free{(\ldots
    \rightarrow \Free{(\toCoq{\tau_n}
    \rightarrow \toCoq{\tau})} \ldots)})}
\]
according to our \ref{eqn:translation:expr:invariant}.
Therefore, we have to wrap all intermediate results with \coq{pure}.
We can do so by rewriting a lambda abstraction with multiple arguments to multiple nested unary lambda abstractions as shown in \autoref{fig:translation:expr:lambda}.

\begin{figure}[H]
  \begin{align*}
    \toCoq{(\haskellM{\@$x$@ -> @$e$@})} &= \coqM{pure (fun @$x'$@ =>}\;\toCoq{e}\coqM{)} \\
    \toCoq{(\haskellM{\@$x_1$@ @$\ldots$@ @$x_n$@ -> @$e$@})} &= \toCoq{(\haskellM{\@$x_1$@ -> @$\ldots$@ -> \@$x_n$@ -> @$e$@})}
    \tag{if $n > 0$}
  \end{align*}
  \caption{Translation rules for lambda abstractions.}
  \label{fig:translation:expr:lambda}
\end{figure}

\subsection{Translation of \haskell{case} and \haskell{if} Expressions}
In this subsection we cover both the translation of \haskell{case} and \haskell{if} expressions.
Since both kinds of expressions behave very similar, their translation rules are based on the same key ideas.
In fact, the Haskell Language Report defines the semantics of \haskell{if} expressions in terms of \haskell{case} expressions \cite[p.~20]{Marlow:2010}.
\[
  \haskellM{if @$e_1$@ then @$e_2$@ else @$e_3$@}
    = \haskellM{case @$e_1$@ of { True -> @$e_2$@ ; False -> @$e_3$@ }}
\]
For simplicity, lets first focus on the translation of \haskell{if} expressions.

Unlike before, we cannot base our translation rule for \haskell{if} expressions on the \ref{eqn:translation:expr:invariant}.
If the expression \haskell{if @$e_1$@ then @$e_2$@ else @$e_3$@} has type $\tau$, both $e_2$ and $e_3$ must also have type $\tau$.
If we naïvely translated the expression by just translating $e_1$ through $e_3$, the resulting term
\[
  \coqM{if @$\toCoqX{e_1}$@ then @$\toCoqX{e_2}$@ else @$\toCoqX{e_3}$@}
\]
satisfies our \ref{eqn:translation:expr:invariant} because $\toCoq{e_2}$ and $\toCoq{e_3}$ both have the type $\toCoq{\tau}$ and therefore the entire term has that type.
Interestingly, if we applied this naïve translation rule, the generated code works.
However, the generated code does not behave as intended.
\begin{minted}{coq}
  Compute (if @$\toCoq{\texttt{True}}$@      then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@). (* ==> $\toCoq{e_1}$ *)
  Compute (if @$\toCoq{\texttt{False}}$@     then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@). (* ==> $\toCoq{e_1}$ *)
  Compute (if @$\toCoq{\texttt{undefined}}$@ then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@). (* ==> $\toCoq{e_2}$ *)
\end{minted}
This odd behaviour results from the flexibility of \coq{if} expressions in Coq.
Coq does not have a build-in boolean type.
Therefore, the condition of \coq{if} expressions can be of any type with exactly two constructors \cite[p.~48]{CoqDevTeam:2018}.
If the condition matches the first constructor, the \coq{then} branch is selected and the \coq{else} branch otherwise.
Since the type of $\toCoq{e_1}$ is \coq{Free @$\Shape$@ @$\Pos$@ (Bool @$\Shape$@ @$\Pos$@)} and \coq{Free} has exactly two constructors \coq{pure} and \coq{impure}, $\toCoq{e_1}$ can be used in \haskell{if} expressions.
The semantics of Coq's \coq{if} expressions fit the observation in the listing above.
\haskell{True} and \haskell{False} are values without an effect.
Therefore, their underlying representation uses the \coq{pure} constructor which is the first constructor of \coq{Free}.
\haskell{undefined} on the other hand does have an effect.
The usage of the \coq{impure} constructor for the representation of effects leads to the \coq{else} branch being selected if the condition is \haskell{undefined}.

What we actually wanted is to test whether the value wrapped by the \coq{pure} constructor is \coq{true} or \coq{false}.
Similar to how we had to unwrap a function expression before we could apply the actual function, we have to bind the condition this time as well.
The bind operation corresponds to the fact that Haskell evaluates the condition to head normal form \cite[p.~132]{Christiansen:2019} before selecting the \haskell{then} or \haskell{else} branch.

\begin{figure}[H]
  \[
    \toCoq{(\haskellM{if @$e_1$@ then @$e_2$@ else @$e_3$@})}
      = \coqM{@$\toCoqX{e_1}$@ >>= (fun (@$x$@ :}\;\toCoq{\haskellM{Bool}}\coqM{) => if @$x$@ then @$\toCoqX{e_2}$@ else @$\toCoqX{e_3}$@)}
  \]
  \caption{Translation rule for \haskell{if} expressions.}
  \label{fig:translation:expr:if}
\end{figure}

With the translation rule shown in \autoref{fig:translation:expr:if} we get the expected behaviour.
\begin{minted}{coq}
  Compute (@$\toCoq{\texttt{True}}$@      >>= (fun (x : @$\toCoq{\texttt{Bool}}$@) => if x then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@)). (* ==> $\toCoq{e_1}$ *)
  Compute (@$\toCoq{\texttt{False}}$@     >>= (fun (x : @$\toCoq{\texttt{Bool}}$@) => if x then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@)). (* ==> $\toCoq{e_2}$ *)
  Compute (@$\toCoq{\texttt{undefined}}$@ >>= (fun (x : @$\toCoq{\texttt{Bool}}$@) => if x then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@)). (* ==> $\toCoq{\texttt{undefined}}$ *)
\end{minted}

Note that we have to annotate the type of the fresh variable $x$ in \autoref{fig:translation:expr:if} and in the examples above explicitly.
The type has to be annotated due to the flexibility of \coq{if} expressions in Coq.
While we know in Haskell that $x$ in \haskell{if @$x$@ then @$e_1$@ else @$e_2$@} has to be of type \haskell{Bool}, $x$ could be of any type with exactly two constructors in Coq.
Therefore, Coq could not infer the type of the fresh variable introduced during the translation of an expression like \haskell{if undefined then @$e_1$@ else @$e_2$@}.
\begin{minted}{coq}
  Fail Compute (@$\toCoq{\texttt{undefined}}$@ >>= (fun x => if x then @$\toCoq{e_1}$@ else @$\toCoq{e_2}$@)).
  (* ==> The command has indeed failed with message:
         Cannot infer a type for this expression. *)
\end{minted}

We can apply the main idea from the translation of \haskell{if} expressions to the translation of \haskell{case} expressions.
Instead of performing pattern matching on the free monad, we want to inspect the actual value.
Thus, we have to add the bind operator.
This time we do not have to annotate the type explicitly because Coq should be able to infer the type from the constructors in the patterns.
Aside from that, the differences between pattern matching in Haskell and Coq shown in \autoref{fig:translation:expr:case} are mostly of syntactical nature.
The observed similarity stems from our initial assumptions.
If we allowed guards or nested patterns for example, the translation of \haskell{case} expressions would be much more difficult.

\begin{figure}[H]
  \[
    \toCoq{\left(
      \begin{array}{l}
        \haskellM{case @$e$@ of}                                                \\
        \quad\haskellM{@$C_1$@ @$x_{1,1}$@ @$\ldots$@ @$x_{1,p_1}$@ -> @$e_1$@} \\
        \quad\vdots                                                             \\
        \quad\haskellM{@$C_n$@ @$x_{n,1}$@ @$\ldots$@ @$x_{n,p_n}$@ -> @$e_n$@}
      \end{array}
    \right)}
    = \begin{array}{l}
      \coqM{@$\toCoqX{e}$@ >>= (fun @$x$@ => match @$x$@ with}                          \\
      \quad\coqM{| @$c_1'$@ @$x_{1,1}'$@ @$\ldots$@ @$x_{1,p_1}'$@ => @$\toCoqX{e_1}$@} \\
      \quad\coqM{| @$\vdots$@}                                                          \\
      \quad\coqM{| @$c_n'$@ @$x_{n,1}'$@ @$\ldots$@ @$x_{n,p_n}'$@ => @$\toCoqX{e_n}$@} \\
      \coqM{end)}
    \end{array}
  \]
  \caption{Translation rule for a \haskell{case} expression that performs pattern matching on an expression $e$ whose type has $n$ constructors $C_1$ through $C_n$. Note that we match the unwrapped Coq term with the regular constructors $c_i'$, not the smart constructors $C_i'$.}
  \label{fig:translation:expr:case}
\end{figure}

The requirement of Coq that pattern matching must be total is also simply passed down to the user of our compiler.
Therefore, pattern matching failures must be handled explicitly using error terms.
The translation of said error terms to Coq is described next.

\subsection{Translation of Error Terms} \label{sec:translation:expr:errors}
So far we have seen no way to introduce actual effects into our programs.
As noted earlier, one important effect that we would like to support is partiality.
In Haskell partiality usually arises from the usage of incomplete pattern matching.
Due to our assumption that pattern matching is total, we have to handle such cases explicitly.
\begin{minted}{haskell}
  head :: [a] -> a
  head xs = case xs of []     -> error "head: empty list"
                       x : xs -> x
\end{minted}
In general, Haskell provides two functions \haskell{error} and \haskell{undefined} that can be used to deliberately cause runtime errors.
If an application of one of those functions is evaluated, the program terminates immediately \cite[p.~16]{Marlow:2010}.
Additionally, a brief description for the cause of the error can be passed to \haskell{error} as demonstrated in the example above already.
\begin{minted}{haskell}
error :: String -> a
undefined :: a
\end{minted}

The question is now how we can implement those two functions in Coq.
The authors of \texttt{hs-to-coq} for example do so by introducing a polymorphic value (or "axiom") \coq{patternFailure} \cite[p.~10]{SpectorZabusky:2017}.
However, as they point out themselves, this axiom is inherently unsound, i.e., can be used to prove arbitrary propositions.
\begin{minted}{coq}
  Local Axiom patternFailure : forall {a}, a.

  Theorem contradiction: False.
  Proof. apply patternFailure. Qed.
\end{minted}

For this reason, avoiding the introduction of such an axiom has been the very motivation for the monadic transformation performed by our implementation.
If we lifted our programs using the \haskell{Maybe} monad for example, we do not need the axiom above, but can represent \haskell{undefined} with \haskell{Nothing}.
\begin{minted}{haskell}
  undefined :: Maybe a
  undefined = Nothing
\end{minted}
For the translation of \haskell{undefined}, we now just need to model the \haskell{Maybe} monad using the free monad, i.e., instantiate $Shape$ and $Pos$ appropriately.
How $SHape$ and $Pos$ would have to look like in case of \haskell{Maybe}, has originally been presented by \cite{Dylus:2018} and will be explained in more detail in \autoref{chp:implementation}. % TODO more concrete reference.

We can also use \haskell{Nothing} to implement \haskell{error} if we are willing to simply discard the error message.
\begin{minted}{haskell}
  error :: String -> Maybe a
  error msg = Nothing
\end{minted}
However, if we want to keep the error message, we need a different monad, i.e., have to instantiate $Shape$ and $Pos$ differently.
This alternative monad would not be limited to the translation of \haskell{error} as we can express \haskell{undefined} in terms of \haskell{error}.
\begin{minted}{haskell}
  undefined :: a
  undefined = error "undefined"
\end{minted}

As we want to leave the choice of the concrete monad to the user, we abstract from the instantiation of $Shape$ and $Pos$ using a type class.
Instances of the type class contain the implementation of \haskell{undefined} and \haskell{error} for the monad represented by $Shape$ and $Pos$.
\begin{minted}{coq}
  Require Import Coq.Strings.String.

  Class Partial (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) :=
    {
      undefined : forall {A : Type}, Free @$\Shape$@ @$\Pos$@ A;
      error     : forall {A : Type}, string -> Free @$\Shape$@ @$\Pos$@ A
    }.
\end{minted}
The code generated by the rules in \autoref{fig:translation:expr:error} uses the interface of \coq{Partial}.
Therefore, the generated code works with any monad for which such an instance can be defined.
For example, we can define a \coq{Partial} instance for the \haskell{Maybe} monad by implementing both \coq{error} and \coq{undefined} with \haskell{Nothing}.
In contrast, no \coq{Partial} instance can be specified for the \coq{Identity} monad.

\begin{figure}[H]
  \begin{align*}
    \toCoq{\haskellM{undefined}}       &= \coqM{undefined} \\
    \toCoq{(\haskellM{error @$msg$@})} &= \coqM{error @$msg$@}
  \end{align*}
  \caption{
    Translation rules for error terms.
    Both rules require an instance of the \coq{Partial} type class for $Shape$ and $Pos$ to be available in the current context.
  }
  \label{fig:translation:expr:error}
\end{figure}

\subsection{Translation of Literals} \label{sec:translation:expr:literals}
The last kind of expression whose translation we did not cover yet are literals.
We support list, pair and integer literals.
As mentioned in \autoref{sec:preliminaries:assumptions} already, list and pair literals are just \textit{syntactic sugar} for the application of their constructors.
Thus, we can specify their translation rules directly as listed in \autoref{fig:translation:expr:literals:list-and-pair}.

\begin{figure}[H]
  \begin{align*}
    \toCoq{\haskellM{[@$e_1$@, @$e_2$@, @$\ldots$@, @$e_n$@]}}
    &= \toCoq{(\haskellM{@$e_1$@ : (@$e_2$@ : (@$\ldots$@ : (@$e_n$@ : [])@$\ldots$@))})}
    \\
    \toCoq{\haskellM{(@$e_1$@, @$e_2$@)}}
    &= \toCoq{(\haskellM{(,) @$e_1$@ @$e_2$@})}
  \end{align*}
  \caption{Translation rules for list and pair literals as derived from \autoref{eqn:translation:assumptions:list-literal} and \autoref{eqn:translation:assumptions:pair-literal}.}
  \label{fig:translation:expr:literals:list-and-pair}
\end{figure}

However, before we can specify how to translate integer literals we have to find an appropriate representation for the type \haskell{Integer} in Coq first.
The Haskell to Coq compiler developed by \cite{Jessen:2019} does not support \haskell{Integer} but translates \haskell{Int} with \coq{nat}.
The type \coq{nat} is defined in Coq's standard library and represents natural numbers.
\begin{minted}{coq}
  Inductive nat : Type
    := O : nat
    |  S : nat -> nat.
\end{minted}
There are two problems that make \coq{nat} unsuitable for the representation of integers. First of all, \coq{nat} can represent arbitrarily large numbers whereas the size of \haskell{Int} is bounded in Haskell.
Even more problematic is the fact that the exact upper bound is not specified.
Nowadays integers are 64 bits wide on most machines.
\begin{minted}{haskell}
  GHCi> maxBound :: Int
  9223372036854775807
\end{minted}
Haskell only guarantees at least 30 bits of precision for \haskell{Int} though \cite[p.~181]{Marlow:2010}.
Proofs would therefore be implementation specific.
For this reason, we avoid \haskell{Int} and use \haskell{Integer} instead.
Similar to \coq{nat}, \haskell{Integer} has no upper bound.
The second problem that remains is that \coq{nat} cannot represent negative numbers.
While \coq{nat} represents $\mathbb{N}$, \haskell{Integer} corresponds to $\mathbb{Z}$.
Therefore, the type \coq{Z} from the \coq{ZArith} library is used by \texttt{hs-to-coq} instead of \coq{nat} \footnote{\url{https://github.com/antalsz/hs-to-coq/blob/0cd052b8162ea53611871d7be3bf186cc38a4a74/hs-to-coq/examples/ghc-base/GHC/Num.v\#L4}}.
\begin{minted}{coq}
  Require Export ZArith.
  Definition Integer := Z.
\end{minted}
We adapt their code slightly such that the definition is compatible with our translation of custom data type and type synonym declarations.
To do so the parameters $Shape$ and $Pos$ must be added, even though \coq{Integer} does not need them.
\begin{minted}{coq}
  Definition Integer (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type := Z.
\end{minted}
The actual integer literals can now be translated by using the numeral notation for \coq{Z}.
In contrast to Haskell, Coq does not support hexadecimal or octal notation.
Thus, we have to convert integer literals to decimal notation first.
By default number literals are interpreted as values of type \coq{nat} by Coq.
To create a value of type \coq{Z}, we have to append the suffix \coq{%Z}.
\begin{minted}{coq}
  Check 42.   (* ==> 42   : nat *)
  Check 42%Z. (* ==> 42%Z : Z *)
\end{minted}
Since \coq{Integer @$Shape$@ @$Pos$@} is just a synonym for \coq{Z}, \coq{42%Z} is also of type $\toCoqT{\haskellM{Integer}}$.
To fulfill our \ref{eqn:translation:expr:invariant}, we finally need to lift the value into the free monad.
\begin{figure}[H]
  \[
    \toCoq{i} = \coqM{
      pure @$i'$@%Z
    }
  \]
  \caption{
    Translation of an integer literal $i$.
    The decimal value of $i$ is denoted $i'$.
  }
  \label{fig:translation:expr:literals:int}
\end{figure}
