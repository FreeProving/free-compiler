-- | This module contains tests for "FreeC.Pass.EtaConversionPass".

module FreeC.Pass.EtaConversionPassTests where

import           Test.Hspec

import           FreeC.Pass.EtaConversionPass
import           FreeC.Monad.Class.Testable
import           FreeC.Monad.Converter
import           FreeC.Test.Parser
import           FreeC.Test.Environment
import           FreeC.Test.Expectations
import qualified FreeC.IR.Syntax               as IR
import           FreeC.Environment

-------------------------------------------------------------------------------
-- Expectation setters                                                       --
-------------------------------------------------------------------------------

-- | Parses the given expressions, applies the eta conversion
--   pass and sets the expectation that the resulting expression
--   is 'FreeC.IR.Similar.similar' to the expected output.
shouldEtaConvertTopLevel :: String -> String -> Converter Expectation
shouldEtaConvertTopLevel inputStr expectedOutputStr = do
  input          <- parseTestFuncDecl inputStr
  expectedOutput <- parseTestFuncDecl expectedOutputStr
  output         <- etaConvertFuncDecl input
  return (output `shouldBeSimilarTo` expectedOutput)

shouldEtaConvert :: String -> String -> Converter Expectation
shouldEtaConvert inputStr expectedOutputStr = do
  input          <- parseTestExpr inputStr
  expectedOutput <- parseTestExpr expectedOutputStr
  output         <- etaConvertExpr input
  return (output `shouldBeSimilarTo` expectedOutput)


-------------------------------------------------------------------------------
-- Tests                                                                     --
-------------------------------------------------------------------------------

-- | Test group for 'etaConversionPass' tests.
testEtaConversionPass :: Spec

testEtaConversionPass = describe "FreeC.Pass.EtaConversionPass" $ do
  context "Top-level eta conversions" $ do
    it
        "applies functions under-applied on the top level to one missing argument"
      $ shouldSucceedWith
      $ do
          _ <- defineTestTypeCon "Foo" 0
          _ <- defineTestFunc "f" 0 "Foo -> Foo"
          _ <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
          "f :: Foo -> Foo = g Foo"
            `shouldEtaConvertTopLevel` "f (y :: Foo) :: Foo = g Foo y"
    it
        "applies functions under-applied on the top level to multiple missing arguments"
      $ shouldSucceedWith
      $ do
          _ <- defineTestTypeCon "Foo" 0
          _ <- defineTestFunc "f" 0 "Foo -> Foo -> Foo"
          _ <- defineTestFunc "g" 3 "Foo -> Foo -> Foo -> Foo"
          "f :: Foo -> Foo -> Foo = g Foo"
            `shouldEtaConvertTopLevel` "f (x :: Foo) (y :: Foo) :: Foo = g Foo x y"
    it "updates function arity in environment" $ shouldSucceedWith $ do
      _     <- defineTestTypeCon "Foo" 0
      _     <- defineTestFunc "f" 0 "Foo -> Foo"
      _     <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
      input <- parseTestFuncDecl "f :: Foo -> Foo = g Foo"
      _     <- etaConvertFuncDecl input
      arity <- inEnv $ lookupArity (IR.ValueScope) (IR.UnQual (IR.Ident "f"))
      return (arity `shouldBe` Just 1)
    it "updates function return type in environment" $ shouldSucceedWith $ do
      _            <- defineTestTypeCon "Foo" 0
      _            <- defineTestFunc "f" 0 "Foo -> Foo"
      _            <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
      input        <- parseTestFuncDecl "f :: Foo -> Foo = g Foo"
      _            <- etaConvertFuncDecl input
      expectedType <- parseTestType "Foo"
      returnType   <- inEnv
        $ lookupReturnType (IR.ValueScope) (IR.UnQual (IR.Ident "f"))
      return (returnType `shouldBeSimilarTo` Just expectedType)
    it "updates function argument type in environment" $ shouldSucceedWith $ do
      _            <- defineTestTypeCon "Foo" 0
      _            <- defineTestFunc "f" 0 "Foo -> Foo"
      _            <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
      input        <- parseTestFuncDecl "f :: Foo -> Foo = g Foo"
      _            <- etaConvertFuncDecl input
      expectedType <- parseTestType "Foo"
      argTypes     <- inEnv
        $ lookupArgTypes (IR.ValueScope) (IR.UnQual (IR.Ident "f"))
      return (argTypes `shouldBeSimilarTo` Just [Just expectedType])
    it
        "applies under-applied function that is if-expression to missing argument"
      $ shouldSucceedWith
      $ do
          _ <- defineTestTypeCon "Foo" 0
          _ <- defineTestFunc "f" 1 "Bool -> Foo -> Foo"
          _ <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
          "f (b :: Bool) :: Foo -> Foo = if b then g Foo else g Foo"
            `shouldEtaConvertTopLevel` "f (b :: Bool) (y :: Foo) :: Foo = if b then g Foo y else g Foo y"
    it
        "applies under-applied function that is if-expression to maximal numer of missing argument in both branches"
      $ shouldSucceedWith
      $ do
          _ <- defineTestTypeCon "Foo" 0
          _ <- defineTestFunc "f" 1 "Bool -> Foo -> Foo"
          _ <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
          _ <- defineTestFunc "h" 1 "Foo -> Foo -> Foo"
          "f (b :: Bool) :: Foo -> Foo = if b then g Foo else h Foo"
            `shouldEtaConvertTopLevel` "f (b :: Bool) (y :: Foo) :: Foo = if b then g Foo y else h Foo y"
    it
        "applies under-applied function that is if-expression to maximal numer of missing argument where one branche is lambda expression"
      $ shouldSucceedWith
      $ do
          _ <- defineTestTypeCon "Foo" 0
          _ <- defineTestFunc "f" 1 "Bool -> Foo -> Foo"
          _ <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
          "f (b :: Bool) :: Foo -> Foo = if b then g Foo else (\\x -> x)"
            `shouldEtaConvertTopLevel` "f (b :: Bool) (y :: Foo) :: Foo = if b then g Foo y else (\\x -> x) y"
    it "works with mutually recursive functions" $ shouldSucceedWith $ do
      _      <- defineTestTypeCon "Foo" 0
      _      <- defineTestFunc "k" 0 " Foo -> Foo"
      _      <- defineTestFunc "f" 0 "Foo -> Foo"
      _      <- defineTestFunc "g" 2 "Foo -> Foo -> Foo"
      moduly <- parseTestModule
        [ "module Test where"
        , "k (fo :: Foo):: Foo -> Foo = f;"
        , "f (fo :: Foo):: Foo -> Foo = g (k Foo)"
        ]
      actualModuly   <- etaConversionPass moduly
      expectedModuly <- parseTestModule
        [ "module Test where"
        , "k :: Foo -> Foo = (\\x -> f x);"
        , "f (x :: Foo) :: Foo = g (k Foo) x"
        ]
      return (actualModuly `shouldBeSimilarTo` expectedModuly)


                        --  k :: Foo -> Foo
            -- k = f
            --  f :: Foo -> Foo
            --  f =  g  (k Foo)


  context "Lower-level eta conversion" $ do
    it "leaves fully applied functions unchanged" $ shouldSucceedWith $ do
      _ <- defineTestTypeCon "Foo" 0
      _ <- defineTestFunc "f" 2 "Foo -> Foo -> Foo"
      "f x y" `shouldEtaConvert` "f x y"
    it "leaves over applied functions unchanged" $ shouldSucceedWith $ do
      _ <- defineTestTypeCon "Foo" 0
      _ <- defineTestFunc "f" 2 "Foo -> Foo -> Foo"
      "f x y z" `shouldEtaConvert` "f x y z"
    it "eta-converts under applied functions" $ shouldSucceedWith $ do
      _ <- defineTestTypeCon "Foo" 0
      _ <- defineTestFunc "f" 2 "Foo -> Foo -> Foo"
      "f x" `shouldEtaConvert` "\\y -> f x y"
    it "leaves application of local variables unchanged"
      $                  shouldSucceedWith
      $                  do
                           "\\(f :: a -> b -> c) x -> f x"
      `shouldEtaConvert` "\\(f :: a -> b -> c) x -> f x"
    it "leaves fully applied constructors unchanged" $ shouldSucceedWith $ do
      _ <- defineTestTypeCon "Foo" 0
      _ <- defineTestTypeCon "Bar" 0
      _ <- defineTestCon "Bar" 2 "Foo -> Foo -> Bar"
      "Bar x y" `shouldEtaConvert` "Bar x y"
    it "leaves over applied functions unchanged" $ shouldSucceedWith $ do
      _ <- defineTestTypeCon "Foo" 0
      _ <- defineTestTypeCon "Bar" 0
      _ <- defineTestCon "Bar" 2 "Foo -> Foo -> Bar"
      "Bar x y z" `shouldEtaConvert` "Bar x y z"
    it "eta-converts under applied functions" $ shouldSucceedWith $ do
      _ <- defineTestTypeCon "Foo" 0
      _ <- defineTestTypeCon "Bar" 0
      _ <- defineTestCon "Bar" 2 "Foo -> Foo -> Bar"
      "Bar x" `shouldEtaConvert` "\\y -> Bar x y"


     --  f :: Foo -> Foo = g Foo
     --
     -- --> f ist eine Funktion vom Typ `Foo -> Foo`
     -- --> f ist eine einstellige Funktion?
     -- --> Nein, f ist eine nullstellige Funktion!
     --
     --  f (y :: Foo) :: Foo = g Foo y
     --
     -- --> f ist eine Funktion vom Typ `Foo`.
     -- --> f ist eine einstellige Funktion!
     --
     -- g: Foo -> Foo -> Foo
     -- h: Foo -> Foo -> foo
     -- f :: Bool -> (Foo -> Foo)
     -- f  b =  if b then g Foo
     -- else h Foo
     --
     -- f: Bool -> Foo -> Foo
     -- f b x = if b


    --  then g Foo x
     -- else h Foo x
     --
     --
     -- h :: Foo -> (Foo -> Foo)
     -- f  b =  if b then g Foo
     -- else h Foo
     --
     -- f b x = if b then g Foo x
     -- else h Foo x
     -- -- oder:
     -- f b = if b then \x -> g Foo x
     --                      else h Foo
     --
     -- -- Bevorzuge erste Alternative
     --
     -- f b x = if b then h Foo x
     -- else g Foo x
     --
     --
     -- ------
     --
     --
     -- f b y = if b then g Foo y
     --                      else (\x  -> x) y
     --  -----
     --
     --  f : nullstellig -> einstellig
     --
     --  in einer funktion k:
     --  vorher f okay
     --  nachher f msste \x -> f x heien
     --
     --  Nutzer definiert k, dass f verwendet
     --  Nutzer definert f
     -- --> Dependency Analysis
     --  f wird definiert
     --  k wird definiert
     --  --> In genau der Reihenfolge wird eta-convertierung durchgefhrt
     --
     --  ==> Problemetasch falls f und k gegenseitig rekursiv sind.
     --
     --  k :: Foo -> Foo
     --  k = f
     --
     --  f :: Foo -> Foo
     --  f =  g  (k Foo)
     --
     -- ---------
     --
     --  k :: Foo -> Foo
     --  k = f
     --  -- nchster Schritt
     --  k = (\x -> f x)
     --
     --  f :: Foo -> Foo
     --  f y =  g  (k Foo) y
