-- | This module contains a compiler pass that checks if all function
--   declarations have complete patten macthing. A pattern ist complete if there
--   is exactly one case alternative for each constructor of the corresponding
--   type.
--
--   = Examples
--
--   == Example 1
--   The following declarations
--
--   > data Maybe a = Just a | Nothing
--   >
--   > fromJust :: Maybe a -> a
--   > fromJust @a (x :: Maybe a) = case (x :: Maybe a) of {Just a -> a}
--
--   should not pass the check.
--
--   == Example 2
--   The following declaration with redundant alternavies
--
--   > redundant :: Just Bool -> Just Bool
--   > redundant (on :: Just Bool) = case (on :: Just Bool) of
--   >                  {Some a -> Some (False)
--   >                  ,None -> None
--   >                  ,Some b -> Some (True)}
--
--   should not pass the check either.
--
--   == Example 3
--   The following declaration where the scrutinee is a function
--
--   > case_id = case \x -> x  of
--
--   should not pass the check.

module FreeC.Pass.CompletePatternPass
  ( completePatternPass
  , checkPatternFuncDecl
  )
where

-- import           Data.Maybe                     ( fromJust )
import           Control.Monad                  ( unless )

import           FreeC.Environment
import           FreeC.Environment.Entry
import qualified FreeC.IR.Syntax               as IR
import           FreeC.IR.SrcSpan
import           FreeC.Monad.Converter
import           FreeC.Monad.Reporter
import           FreeC.Pass

-- | Checks that all functions of a given module have complete pattern matching.
--   The pattern matching is complete if there is exactly one case alternative
--   for each constructor of the corresponding type.
completePatternPass :: Pass IR.Module
completePatternPass ast = do
  mapM_ checkPatternFuncDecl (IR.modFuncDecls ast)
  return ast

-- | Checks a funcDecl for incomplete Patterns
checkPatternFuncDecl :: IR.FuncDecl -> Converter ()
checkPatternFuncDecl funcDecl = checkPatternExpr (IR.funcDeclRhs funcDecl)
 where
  checkPatternExpr :: IR.Expr -> Converter () -- Expr
  checkPatternExpr (IR.Case srcSpan exprScrutinee exprAlts _) = do
    case IR.exprType (exprScrutinee) >>= getTypeConName of
      Nothing       -> failedPatternCheck srcSpan
      Just typeName -> do
        env <- getEnv
        let altConNames = map (IR.conPatName . IR.altConPat) exprAlts
        case lookupEntry IR.TypeScope typeName env of
          Just entry | isDataEntry entry ->
            performCheck (entryConsNames entry) altConNames srcSpan
          Just entry | isTypeSynEntry entry ->
            case
                getTypeConName (entryTypeSyn entry)
                  >>= \e -> lookupEntry IR.TypeScope e env
              of
                Just entry' ->
                  performCheck (entryConsNames entry') altConNames srcSpan
                _ -> failedPatternCheck srcSpan
          _ -> failedPatternCheck srcSpan
  checkPatternExpr (IR.App _ lhr rhs _) =
    checkPatternExpr lhr >> checkPatternExpr rhs
  checkPatternExpr (IR.TypeAppExpr _ lhr _ _) = checkPatternExpr lhr
  checkPatternExpr (IR.If _ exprCond exprThen exprElse _) =
    checkPatternExpr exprCond
      >> checkPatternExpr exprThen
      >> checkPatternExpr exprElse
  checkPatternExpr (IR.Lambda _ _ lambdaRhs _) = checkPatternExpr lambdaRhs
  checkPatternExpr IR.Con{}                    = return ()
  checkPatternExpr IR.Var{}                    = return ()
  checkPatternExpr IR.Undefined{}              = return ()
  checkPatternExpr IR.ErrorExpr{}              = return ()
  checkPatternExpr IR.IntLiteral{}             = return ()

  performCheck :: [IR.ConName] -> [IR.ConName] -> SrcSpan -> Converter ()
  performCheck typeConNames altConNames srcSpan = unless
    (  all (\x -> elem x typeConNames) typeConNames
    && length typeConNames
    == length altConNames
    )
    (failedPatternCheck srcSpan)

  failedPatternCheck :: SrcSpan -> Converter ()
  failedPatternCheck srcSpan =
    reportFatal
      $  Message srcSpan Error
      $  "Incomplete pattern in function: "
      ++ stringFromName (IR.funcDeclName funcDecl)

  stringFromName :: IR.Name -> String
  stringFromName (IR.Ident  s) = s
  stringFromName (IR.Symbol s) = s

  getTypeConName :: IR.Type -> Maybe IR.TypeConName
  getTypeConName (IR.TypeCon _ typeConName ) = Just typeConName
  getTypeConName (IR.TypeApp _ typeAppLhs _) = getTypeConName typeAppLhs
    -- The type of the scrutinee shouldn't be function or a type var
  getTypeConName IR.TypeVar{}                = Nothing
  getTypeConName IR.FuncType{}               = Nothing
