\section{Haskell Parser} \label{sec:implementation:haskell-src-exts}
In the first stage of the compilation process, the input file is parsed into an AST.
We have not implemented our own Haskell parser for this purpose but are using the \texttt{haskell-src-exts} package\footnote{\url{http://hackage.haskell.org/package/haskell-src-exts}} instead.
\texttt{haskell-src-exts} provides a Haskell parser, AST and pretty printer for Haskell and supports a variety of language extensions in addition to standard Haskell.
On the one hand, the advantage of using the \texttt{haskell-src-exts} is that it allows us to easily add support for further language features in the future.
On the other hand, \texttt{haskell-src-exts} extensive language support makes it difficult to work directly on its AST.

For example, if we used this data structure to implement the translation of type expressions directly, we would have to consider 19 different constructors of the type that represents type expressions in \texttt{haskell-src-exts}.
Many of those constructors represent either kinds of type expressions that are part of some language extension or not supported by our compiler yet.
Therefore, we would have to ignore a lot of constructors in the implementation of the translation rules.
Handling only a subset of the constructors of complex data structures comes at the risk of accidentally missing a case that would have been relevant.
Besides the large number of constructors, the hierarchical structure of the AST makes it difficult to reason about source code that uses the AST.
In consequence, we do not work directly with on the AST from \texttt{haskell-src-exts} but use a custom data structure described in the next subsection.
