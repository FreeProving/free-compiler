\section{Architecture} \label{sec:implementation:architecture}
The Haskell to Coq compiler presented in this thesis is written in Haskell itself.
To manage dependencies and to build the compiler, we are using Cabal\footnote{\url{https://www.haskell.org/cabal/}}.
Instructions for how to setup, build and run the compiler can be found in \autoref{appendix:usage}.

The compilation process for the translation of a Haskell module to Coq is outlined in \autoref{fig:implementation:architecture}.
First, Haskell files are parsed into a data structure known as an \textit{abstract syntax tree} ("AST").
In the second stage, the AST is converted to an intermediate representation that simplifies the analysis and conversion of the Haskell program in the subsequent stages.
The converter transforms the simplified Haskell AST to a Coq AST that is printed to the console or output file in the final stage of the compilation process.

\begin{figure}[p]
  \digraph[scale=0.75]{CompielerArchitecture}{
    node [shape = "rect", width = 2];

    input  [label = "Haskell Source File", color = "white"];
    parser [label = "Parser"];
    simplifier [label = "Simplifier"];
    deps_analysis [label = "Dependency Analysis"];
    partial_analysis [label = "Partiality Analysis"];
    pretty_printer [label = "Pretty Printer"];
    type_conversion [label = "Type Conversion"];
    func_conversion [label = "Function Conversion"];
    output [label = "Coq Source File", color = "white"];

    input            -> parser;
    parser           -> simplifier        [label = "  Haskell AST"];
    simplifier       -> deps_analysis     [label = "  Simplified AST"];
    deps_analysis    -> partial_analysis;
    partial_analysis -> type_conversion;
    type_conversion  -> func_conversion;
    func_conversion  -> pretty_printer    [label = "  Coq AST"];
    pretty_printer   -> output;
  }
  \caption{
    Stages of the compilation process from Haskell to Coq.
    Arrows are labeled with the component of the compiler that is responsible for converting one intermediate representation to another.
  }
  \label{fig:implementation:architecture}
\end{figure}

% \begin{figure}[H]
%   \digraph[scale=0.6]{CompielerArchitecture}{
%     node[shape="rect"];
%     edge[minlen=1];
%     rankdir="LR";
%
%     # Left nodes.
%     \{
%       rank="same";
%       node[width=2];
%       input[label="Haskell source file"];
%       haskellAst[label="Haskell AST"];
%       simpleAst[label="Simplified AST"];
%     \}
%
%     # Right nodes.
%     \{
%       rank="same";
%       node[width=3];
%       output[label="Coq source file"];
%       coqAst[label="Coq AST"];
%       scc[label="Strongly Connected Components"];
%     \}
%
%     # Invisible edges between opposite facing nodes.
%     input      -> output [style="invis"];
%     haskellAst -> coqAst [style="invis"];
%
%     # Vertical edges pointing down.
%     input      -> haskellAst [xlabel="Parser&nbsp;&nbsp;&nbsp;"];
%     haskellAst -> simpleAst  [xlabel="Simplifier&nbsp;&nbsp;&nbsp;"];
%
%     # Horizontal edge.
%     simpleAst  -> scc        [label="Dependency Analysis"];
%
%     # Vertical edges pointing up.
%     coqAst     -> scc        [dir="back",xlabel="Converter&nbsp;&nbsp;&nbsp;"];
%     output     -> coqAst     [dir="back",xlabel="Pretty Printer&nbsp;&nbsp;&nbsp;"];
%   }
%   \caption{
%     Stages of the compilation process from Haskell to Coq.
%     Arrows are labeled with the component of the compiler that is responsible for converting one intermediate representation to another.
%   }
%   \label{fig:implementation:architecture}
% \end{figure}

Using Haskell for the implementation of our compiler allows us to make use of Haskell's package infrastructure.
Especially, the Haskell and Coq parsers, ASTs and pretty printers have not been implemented by our self.
In the following sections more details will be given regarding the individual stages and used libraries.
