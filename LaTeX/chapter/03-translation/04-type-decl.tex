\section{Translation of Type Declarations} \label{sec:translation:type-decl}
This section covers the translation of type synonyms and data type declarations.

Because the order of declarations matters in Coq, special care needs to be taken to translate only declarations whose dependencies were translated before.
We say that a type expression $\tau$ depends on the declaration of a type constructor $T$ (e.g. the name of a type synonym or data type declaration) if $\tau$ contains an application of the type constructor $T$.
For short we also say that $\tau$ depends on or uses $T$.
A type synonym now depends on all type constructor used by its right-hand side.
Likewise, a data type declaration depends on all type constructors used by the fields of its data constructors.

For simplicity we will first consider only individual declarations and assume all additional data types used by our examples to have been declared beforehand.
At the end of this section, we describe how to translate multiple type declarations without introducing dependency related issues to the generated Coq code.
We also extend the translation rules to support mutually recursive declarations in the final subsection.

\subsection{Translation of Type Synonym Declarations} \label{sec:translation:type-decl:type-syn}
Type synonyms can be used in Haskell to give a name to a more complex type expression.
Similarly we can use a \coq{Definition}-sentence to to assign a name to a term in Coq.
Because Coq does not distinguish types and terms, declarations of type synonyms can be simply translated to \coq{Definition}-sentences as shown in \autoref{fig:translation:type-decl:type-syn}.

\begin{figure}[H]
  \begin{align*}
    \toCoq{(
      \haskellM{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@}
     )}
    = \coqM{Definition @$S'$@} &\;\coqM{(@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)           } \\
                               &\;\coqM{(@$\alpha_1'$@ @$\ldots$@ @$\alpha_n'$@ : Type)} \\
                               &\;\coqM{: Type                                         } \\
                               &\;\coqM{:= @$\toCoqTX{\tau}$@.                             }
  \end{align*}
  \caption{Translation rule for $n$-ary polymorphic type synonym declarations.}
  \label{fig:translation:type-decl:type-syn}
\end{figure}

The parameters $\Shape$ and $\Pos$ have to be added such that the translated type can use the free monad or other data types.
For example the following type synonym
\begin{minted}{haskell}
  type Queue a = List a
\end{minted}
needs $\Shape$ and $\Pos$ when translated to to Coq because they need to be passed to \coq{List}.
\begin{minted}{coq}
  Definition Queue (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
                   := List @$\Shape$@ @$\Pos$@ a.
\end{minted}

On the right-hand side of the \coq{Definition}-sentence in \autoref{fig:translation:type-decl:type-syn} the $\toCoqT{}$ translation is applied instead of $\toCoq{}$.
This is because we desire the expansion of type synonyms in Haskell and Coq to be compatible with respect to the $\toCoq{}$ translation.
To convince ourselves that the translation rule above fulfills this property lets denote the expansion of type synonyms in Haskell and Coq with $\beta_H$ and $\beta_C$ respectively and show that for all type synonyms \haskell{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@} and type expressions $\tau_1, \ldots \tau_n$ the following holds true.
\[
  \toCoq{\beta_H(S\;\tau_1\;\ldots\;\tau_n)}
  = \beta_C(\toCoq{(S\;\tau_1\;\ldots\;\tau_n)})
\]

For the instantiation of $S$ and $S'$ we first define substitutions $\sigma$ and $\sigma'$.
\begin{align*}
  \sigma &\coloneqq \{\, \alpha_1 \mapsto \tau_1, \ldots, \alpha_n \mapsto \tau_n \,\} \\
  \sigma' &\coloneqq \{\, \alpha_1' \mapsto \toCoqT{\tau_1}, \ldots, \alpha_n' \mapsto \toCoqT{\tau_n} \,\}
\end{align*}
Now we can proof the proposition by applying the translation rules for types presented in the previous section.

\begin{align*}
  \toCoq{\beta_H(S\;\tau_1\;\ldots\;\tau_n)}
    &= \toCoq{\sigma(\tau)}
       \tag{expansion of $S$} \\
    &= \Free{\toCoqT{\sigma(\tau)}}
       \tag{\autoref{eqn:translation:type}} \\
    &= \Free{\sigma'(\toCoqT{\tau})}
       \tag{$\star$} \\
    &= \beta_C{(\Free{(\genApply{S'}\;\toCoqT{\tau_1}\;\ldots\;\toCoqT{\tau_n})})}
       \tag{undo expansion of $S'$} \\
    &= \beta_C{(\Free{\toCoqT{(S\;\tau_1\;\ldots\;\tau_n)}})}
       \tag{\autoref{eqn:translation:type:application} and \ref{eqn:translation:type:constructor}} \\
    &= \beta_C(\toCoq{(S\;\tau_1\;\ldots\;\tau_n)})
       \tag{\autoref{eqn:translation:type}}
\end{align*}
\qed

The equation marked with $(\star)$ follows from the following property of $\sigma$ and $\sigma'$.
\begin{align*}
  \toCoqT{\sigma(\alpha_i)} = \toCoqT{\tau_i}
                            = \sigma'(\alpha_i')
                            = \sigma'(\toCoqT{\alpha_i})
  &&\forall i \in \{\, 1, \ldots, n \,\}
\end{align*}
We assume without a proof that this property holds for the extensions of $\sigma$ and $\sigma'$ as well.

\subsection{Translation of Data Type Declarations} \label{sec:translation:type-decl:data}
Until now we have described how to translate type expressions and assign names to them but we are not able to actually define our own types for usage in those type expressions.
One of the simplest kinds of data types that can be defined in Haskell are so called \textit{sum types}.
A well known example for a sum type is \haskell{Bool} which is commonly defined as follows.
\begin{minted}{haskell}
  data Bool = True | False
\end{minted}
In general, the constructors of a sum type do not have any arguments and are enumerated on the right-hand side of a \haskell{data} type declaration.
In Coq data types are defined using \coq{Inductive}-sentences in a very similar fashion to \haskell{data} declarations in Haskell.
The \haskell{Bool} type could look like this for example.
\begin{minted}{coq}
  Inductive Bool : Type
    := true  : Bool
     | false : Bool.
\end{minted}
Apart from the concrete syntax, the main difference is that the type of the constructors is annotated explicitly.
In contrast to Haskell, we follow the Coq convention to choose lower case names for the constructors.

Sum types on their own are usually not very useful.
Instead one wishes to compose existing data types to more interesting data structures.
Such types are referred to as \textit{product types}.
If there was for instance a type \haskell{Double} that represents floating point numbers, we could compose two such numbers to model a complex number.
\begin{minted}{haskell}
  data Complex = Complex Double Double
\end{minted}
This time the constructor \haskell{Complex} is not a constant like \haskell{True} but a function that takes two values of type \haskell{Double} and produces a \haskell{Complex} number.
\begin{minted}{haskell}
  GHCi> :t Complex
  Complex :: Double -> Double -> Complex
\end{minted}
This insight is important, as we need to annotate the full type of the constructor in Coq again.
By applying the translation rules for types we would obtain the following Coq type for the constructor.
\begin{align*}
  \toCoqT{(Double \rightarrow Double \rightarrow Complex)}
    &= \toCoq{Double} \rightarrow \toCoq{(Double \rightarrow Complex)}
    \tag{\autoref{eqn:translation:type:function}}
    \\
    &= \toCoq{Double} \rightarrow \Free{\toCoqT{(Double \rightarrow Complex)}}
    \tag{\autoref{eqn:translation:type}}
\end{align*}
Wrapping the return type of a constructor is not allowed in Coq though.
However, it is not necessary for us to lift the intermediate results of the constructor either.
This is because (partial) constructor applications never have an effect in Haskell.
Therefore, it is sufficient to lift the argument types of the constructor (which could indeed be effectful).
For this purpose we still need to add the parameters $\Shape$ and $\Pos$ to the generated sentence.
\begin{minted}{coq}
  Inductive Complex (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type
    := complex : Free @$\Shape$@ @$\Pos$@ (Double @$\Shape$@ @$\Pos$@)
              -> Free @$\Shape$@ @$\Pos$@ (Double @$\Shape$@ @$\Pos$@)
              -> Complex @$\Shape$@ @$\Pos$@.
\end{minted}

Haskell allows us to use \textit{parametric polymorphism} to generalize from this example and define pairs of two arbitrary types.
\begin{minted}{haskell}
  data Pair a b = Pair a b
\end{minted}
Analogously to how we added the parameters $\Shape$ and $\Pos$ above, we can also introduce the type variables $a$ and $b$ in the header of the \coq{Inductive}-sentence.
\begin{minted}{coq}
  Inductive Pair (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a b : Type) : Type
    := pair : Free @$\Shape$@ @$\Pos$@ a
              -> Free @$\Shape$@ @$\Pos$@ b
              -> Pair @$\Shape$@ @$\Pos$@ a b.
\end{minted}
We wrap the binders of $a$ and $b$ in regular parentheses, because we want to pass the type arguments explicitly to \coq{Pair} when we instantiate the data type.
However, Coq also adds all parameters of the \coq{Inductive}-sentence to the constructors automatically, i.e. \coq{pair} takes four additional parameters.
\begin{minted}{coq}
  Check pair.
  (* ==> pair : forall (Shape : Type) (Pos : Shape -> Type) (a b : Type),
                Free Shape Pos a -> Free Shape Pos b -> Pair Shape Pos a b *)
\end{minted}
For convenience we can "hide" those arguments using an \coq{Arguments}-sentence.
\begin{minted}{coq}
  Arguments pair {@$\Shape$@} {@$\Pos$@} {a} {b}.
\end{minted}
Coq will then try to infer the values of $\Shape$, $\Pos$, $a$ and $b$ from the context as well as the types of the remaining arguments.

Both Haskell and Coq do not require us to distinguish sum and product types.
For example, we can combine both concepts to define a data type for optional values.
\begin{minted}{haskell}
  data Maybe a = Nothing | Just a
\end{minted}
As shown in \autoref{fig:translation:type-decl:data}, an arbitrary data type can be translated similar to how we translated product types above.
Just as with sum types, additional constructors are separated by a vertical bar.

\begin{figure}[H]
  \[
    \toCoq{\left(
      \begin{array}{ll}
        \haskellM{data @$D$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@}              \\
          \quad\haskellM{= @$C_1$@ @$\tau_{1,1}$@ @$\ldots$@  @$\tau_{1,p_1}$@} \\
          \quad\haskellM{| @$\ldots$@}                                          \\
          \quad\haskellM{| @$C_m$@ @$\tau_{m,1}$@ @$\ldots$@  @$\tau_{m,p_m}$@}
      \end{array}
    \right)}
    = \begin{array}{l}
      \coqM{Inductive @$D$@ (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)}                      \\
      \phantom{\coqM{Inductive @$D$@}}\;\;\coqM{(@$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ : Type) : Type} \\
      \quad\coqM{:= @$c_1'$@ : @$\toCoqX{\tau_{1,1}}$@ -> @$\ldots$@ -> @$\toCoqX{\tau_{1,p_1}}$@ -> @$\toCoqTX{(D\;\alpha_1\;\ldots\;\alpha_n)}$@} \\
      \quad\;\;\coqM{| @$\ldots$@}                                                                                                                             \\
      \quad\;\;\coqM{| @$c_m'$@ : @$\toCoqX{\tau_{m,1}}$@ -> @$\ldots$@ -> @$\toCoqX{\tau_{m,p_m}}$@ -> @$\toCoqTX{(D\;\alpha_1\;\ldots\;\alpha_n)}$@.}
    \end{array}
  \]
  \caption{Translation rule for $n$-ary polymorphic data type declarations with $m$ constructors. In Coq we are using renamed lower case variations $c_i'$ of the Haskell constructors $C_i$.}
  \label{fig:translation:type-decl:data}
\end{figure}

If we apply this translation rule to our \haskell{Maybe} data type, we obtain the following \coq{Inductive}-sentence for example.
\begin{minted}{coq}
  Inductive Maybe (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
    := nothing : Maybe @$\Shape$@ @$\Pos$@ a
     | just    : Free @$\Shape$@ @$\Pos$@ a -> Maybe @$\Shape$@ @$\Pos$@ a.
\end{minted}

Before we conclude this section, notice that we are using the $\toCoqT{}$ translation for the return type of constructors in \autoref{fig:translation:type-decl:data}.
This is because $\toCoq{}$ would lift the type to the free monad but Coq does not allow us to wrap the return type of constructors as we pointed out above already.
However, we are usually interested in lifted values.
With that end in view, we define a function for each regular constructor that simply applies the constructor and lifts it's result using the \coq{pure} constructor of the free monad.
We are going to refer to these functions as \textit{smart constructors} hereinafter.
The smart constructor for \coq{just} would look as follows.
\begin{minted}{coq}
  Definition Just (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) {a : Type}
                  (x : Free @$\Shape$@ @$\Pos$@ a)
                  : Free @$\Shape$@ @$\Pos$@ (Maybe @$\Shape$@ @$\Pos$@ a)
                  := pure (just x).
\end{minted}
This time we are using upper case identifiers again.
Unlike with regular constructor, we do not have to generate an \coq{Arguments}-sentence for the smart constructor.
This is because we can mark the type argument as implicit directly in the \coq{Definition}-sentence by wrapping its binder in curly braces.
The general generation scheme for smart constructors and \coq{Arguments}-sentences is summarized in \autoref{fig:translation:type-decl:con}.
In case of \coq{Just} we were able to manually choose appropriate names for the arguments of the smart constructor.
However, when we generate those sentences, we need to generate \textit{fresh identifiers} automatically.
The generation of fresh identifiers will be covered in \autoref{chp:implementation}. % TODO more specific reference.

\begin{figure}[H]
  \begin{minted}{coq}
    Arguments @$c'$@ {@$\Shape$@} {@$\Pos$@} {@$\alpha_1$@} @$\ldots$@ {@$\alpha_n$@}.

    Definition @$C'$@ (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) {@$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ : Type}
                  (@$x_1$@ : @$\toCoq{\tau_1}$@) @$\ldots$@ (@$x_p$@ : @$\toCoq{\tau_p}$@)
                  : @$\toCoq{(D\;\alpha_1\;\ldots\;\alpha_n)}$@
                  := pure (@$C$@ @$x_1$@ @$\ldots$@ @$x_p$@).
  \end{minted}
  \caption{Additional sentences to generate for each data constructor \haskell{@$C$@ @$\tau_1$@ @$\ldots$@ @$\tau_p$@} of a data type \haskell{@$D$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@}. $c'$ refers to the renamed lower case constructor name. $x_1, \ldots, x_p$ are fresh identifiers.}
  \label{fig:translation:type-decl:con}
\end{figure}

\subsection{Handling Mutually Recursive Type Declarations} \label{sec:translation:type-decl:rec}
In Haskell the order of declarations does not matter.
Therefore, \haskell{A} is allowed to use \haskell{B} in the following example, even though \haskell{B} is declared after \haskell{A}.
\begin{minted}{haskell}
  data A = A B
  data B = B
\end{minted}
In Coq this is not the case.
If we convert the example to Coq, the declaration of \coq{B} must precede the declaration of \coq{A}.
\begin{minted}{coq}
  Fail Inductive A (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type := a : @$\toCoq{\texttt{B}}$@ -> @$\toCoqT{\texttt{A}}$@.
  (* ==> The command has indeed failed with message:
         The reference B was not found in the current environment. *)
  Inductive B (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type := b : @$\toCoqT{\texttt{B}}$@.
\end{minted}
For this reason we have to analyse the dependencies of all data type declarations in the Haskell module before we translate them to Coq.
As a first approach, we can simply sort the declarations according to their dependencies.
In the example above, we would obtain the list \haskell{[B, A]} of sorted data type declarations.
Translating the declarations in that order, yields a valid Coq program.
\begin{minted}{coq}
  Inductive B (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type := b : @$\toCoqT{\texttt{B}}$@.
  Inductive A (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type := a : @$\toCoq{\texttt{B}}$@ -> @$\toCoqT{\texttt{A}}$@.
\end{minted}

% Recursive data types.
This approach also suffices to translate simple \textit{recursive data types} such as \haskell{List}.
\begin{minted}{haskell}
  data List a = Nil | Cons a (List a)
\end{minted}
A data type is called recursive if values of that type are used to construct new values of the same type.
Because Coq allows \coq{Inductive}-sentences to use the data type that is declared in the same sentence, we can apply the existing translation rule in such cases directly.
\begin{minted}{coq}
  Inductive List (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
    := nil  : List @$\Shape$@ @$\Pos$@ a
     | cons : Free @$\Shape$@ @$\Pos$@ a -> Free @$\Shape$@ @$\Pos$@ (List @$\Shape$@ @$\Pos$@ a) -> List @$\Shape$@ @$\Pos$@ a.
\end{minted}

% Mutually recursive data types.
However, this cannot be done in case of \textit{mutually recursive data types}.
\begin{minted}{haskell}
  data Tree a = Tree a (Forest a)
  data Forest a = Empty | NonEmpty (Tree a) (Forest a)
\end{minted}
The declarations of \haskell{Tree} depends on the declaration of \haskell{Forest} and vice versa.
Regardless of which data type we choose to translate first, Coq will reject the generated code as the other one will be undefined.
As we have seen in case of ordinary recursive data types like \coq{List}, Coq allows us to use the data type defined by an \coq{Inductive}-sentence within that sentence.
Thus, we need a mechanism to define both \coq{Tree} and \coq{Forest} in the same \coq{Inductive}-sentence, such that they can use each other.
Coq offers the \coq{with} keyword for this purpose.
It is used to concatenate multiple \coq{Inductive}-sentences to a single sentence.
In the example above, the following would work.
\begin{minted}{coq}
  Inductive Tree (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
    := tree : Free @$\Shape$@ @$\Pos$@ a -> Forest @$\Shape$@ @$\Pos$@ a -> Tree @$\Shape$@ @$\Pos$@ a
  with Forest (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
    := empty    : Forest @$\Shape$@ @$\Pos$@ a
    |  nonEmpty : Free @$\Shape$@ @$\Pos$@ (Tree @$\Shape$@ @$\Pos$@ a) -> Forest @$\Shape$@ @$\Pos$@ a.
\end{minted}

% Dependency analysis.
The question that remains is how we can identify mutually recursive data type declarations.
For this purpose we represent the dependencies among the data types as a directed graph.
The nodes of the \textit{dependency graph} correspond to data type and type synonym declarations.
There is an edge between the nodes of two declarations $D_1$ and $D_2$ if and only if $D_1$ depends on $D_2$.
The dependency graphs for the data type declarations covered in this subsection so far are depicted in \autoref{fig:translation:type-decl:graph1}.

\begin{figure}[H]
  \digraph[scale=0.75]{ExampleTypeDependencyGraphs}{
    A -> B;
    List -> List;
    Tree -> Forest; Forest -> Tree;
  }
  \caption{Dependency graphs for the data types \haskell{A} and \haskell{B}, \haskell{List} as well as \haskell{Tree} and \haskell{Forest} as defined above.}
  \label{fig:translation:type-decl:graph1}
\end{figure}

If there is an edge between $D_1$ and $D_2$, $D_2$ needs to be declared before or in the same sentence as $D_1$.
The same is true if there is a path from $D_1$ to $D_2$.
If a path from $D_2$ to $D_1$ exists as well, it follows that they need to be declared in the same sentence.
In our concrete examples that means that \haskell{B} needs to be declared before \haskell{A} because there is an edge from \haskell{A} to \haskell{B}.
It would also be okay to declare them in the same sentence.
\haskell{Tree} and \haskell{Forest} on the other hand definitely need to be declared in the same sentence, as the corresponding nodes are reachable from each other.

In graph theory a set of nodes with the property that all nodes within the set are reachable from all other nodes within the set is referred to as a \textit{strongly connected component} of the graph.
In our case that means that all declarations whose nodes form a strongly connected component of the dependency graph need to be declared in the same sentence.
Likewise, if two declarations depend on each other~--~and therefore need to be declared in the same sentence~--~they are also necessarily in the same strongly connected component.
Thus, the identification of mutually recursive data type declarations coincides with the identification of strongly connected components of the dependency graph.
There are algorithms to compute strongly connected components in linear time.
As a final step the identified strongly connected components need to be sorted.
If the component $SCC_1$ contains at least one declaration that depends on a declaration in $SCC_2$, $SCC_2$ should precede $SCC_1$.
This is also referred to as \textit{reverse topological order} and can be solved in linear time as well.
In our case we obtain the following sorted lists of strongly connected components:
\begin{align*}
  [\{\, \haskellM{B} \,\}, \{\, \haskellM{A} \,\}]
  && [\{\, \haskellM{List} \,\}]
  && [\{\, \haskellM{Tree}, \haskellM{Forest} \,\}]
\end{align*}

% Type synonyms in recursive data types.
There is one additional caveat to be aware of.
Until now we only considered mutually recursive data type declarations.
This is because type synonym declarations are not allowed to form a cycle on their own.
Thus, the following is invalid in Haskell.
\begin{minted}{haskell}
  type A = B
  type B = A
\end{minted}
However, it is perfectly fine for a type synonym declaration to be part of a cycle formed by data type declarations.
For example, one may notice that the \haskell{Forest} data type we defined earlier, can also be expressed in terms of \haskell{List}.
\begin{minted}{haskell}
  data Tree a = Tree a (Forest a)
  type Forest a = List (Tree a)
\end{minted}
Again, \haskell{Tree} and \haskell{Forest} form a strongly connected component of the dependency graph.
Unlike before, we cannot use the \coq{with} keyword in this case.
This is because \haskell{Tree} is translated to an \coq{Inductive}-sentence while \haskell{Forest} is translated to a \coq{Definition}-sentence.
But \coq{with} can only be used to join two or more \coq{Inductive}-sentences.
The solution is to expand type synonyms that occur within such a strongly connected component.
After this preprocessing step we obtain the following Haskell declarations.
\begin{minted}{haskell}
  data Tree a = Tree a (List (Tree a))
  type Forest a = List (Tree a)
\end{minted}
\haskell{Forest} still depends on \haskell{Tree} and needs to be translated afterwards.
However, \haskell{Tree} can now be translated independently as can be seen in \autoref{fig:translation:type-decl:graph2}.

\begin{figure}[H]
  \begin{center}
    \begin{minipage}[t]{0.45\textwidth}
      \begin{center}
        \digraph[scale=0.75]{ExampleTypeDependencyGraphBeforeInlining}{
          subgraph cluster_scc {
            graph[style = "dotted"];
            { rank = "same"; Tree; Forest; }
          }
          List;
          Forest -> Tree;
          Forest -> List;
          Tree   -> Forest;
        }
        $[\{\, \haskellM{List} \,\}, \{\, \haskellM{Tree}, \haskellM{Forest} \,\}]$
      \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.45\textwidth}
      \begin{center}
        \digraph[scale=0.75]{ExampleTypeDependencyGraphAfterInlining}{
          { rank = "same"; Tree; Forest; }
          List;
          Forest -> Tree;
          Forest -> List;
          Tree   -> List;
        }
        $[\{\, \haskellM{List} \,\}, \{\, \haskellM{Tree} \,\}, \{\, \haskellM{Forest} \,\}]$
      \end{center}
    \end{minipage}
  \end{center}
  \caption{
    Dependency graphs for \haskell{Tree} and \haskell{Forest} before inlining the type synonym \haskell{Forest} into the definition of \haskell{Tree} (left) and after inlining (right).
    Strongly connected components are listed in reverse topological order below the graphs.
  }
  \label{fig:translation:type-decl:graph2}
\end{figure}

If there are more than one type synonyms in the strongly connected component, we need to sort them with respect to their dependencies among each other.
But as pointed out above, we can be sure in those cases that they do not form a cycle themselves.
Therefore, it is fine to translate them individually as we did before.
