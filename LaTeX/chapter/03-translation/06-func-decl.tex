\section{Translation of Function Declarations} \label{sec:translation:func-decl}
In this final section of the chapter we will cover the translation of the eponymous component for functional programming languages: function declarations.

Just as with type declarations the order of function declarations matters in Coq as well.
Thus, we have to perform a dependency analysis again.
Although the basic principles of the dependency analysis still apply, adding support for recursive and mutually recursive functions is more involved this time.
This is because Coq strictly distinguishes recursive and non-recursive function declarations.
Therefore, it is not sufficient to simply concatenate generated sentences.
Instead, we have to apply a completely different translation scheme to recursive function declarations.
For this reason, we will focus on non-recursive function declarations first.
The translation of recursive functions is covered in the second half of this section.
In the last section, there are some remarks regarding the translation of partial functions.

\subsection{Translation of Non-Recursive Functions}
In \autoref{sec:translation:type-decl} we have already seen function declarations in Coq on the example of smart constructors.
In order to recall the basic structure of such function declarations, consider the following implementation of boolean negation without monadic lifting.
\begin{minted}{coq}
  Definition not (b : bool) : bool :=
    match b with
    | true  => false
    | false => true
    end.
\end{minted}
As we can see, Coq's function declarations are parameterized \coq{Definition} sentences.
Unlike in Haskell, there are not multiple rules and pattern matching is performed explicitly on the right-hand side using \coq{match} expressions.
The return type of the function as well as the types of its arguments are annotated inside the declaration itself.
Due to our assumptions, i.e., that there is only one rule and the parameters are variable patterns, all Haskell function declarations we are concerned with already look remarkably similar to the \coq{Definition} sentences that we need to generate.
\begin{minted}{haskell}
  @$f$@ :: @$\tau$@
  @$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@
\end{minted}
The main difference here is that the type signature is independent of the actual function declaration.
If we had a type signature of the form \haskell{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@}, we could apply the translation proposed in \autoref{fig:translation:func-decl:non-rec} directly.
Note that we implicitly apply the optimization by \cite{Abel:2005} again, i.e.,
the type of the converted function is not $\toCoq{(\tau_1 \rightarrow \ldots \rightarrow \tau_n \rightarrow \tau)}$ but $\toCoq{\tau_1} \rightarrow \ldots \rightarrow \toCoq{\tau_n} \rightarrow \toCoq{\tau}$.

\begin{figure}[H]
  \[
    \toCoq{\left(
      \begin{array}{l}
        \haskellM{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@} \\
        \haskellM{@$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@}
      \end{array}
    \right)}
    = \begin{array}{ll}
        \coqM{Definition @$f'$@}
          &\coqM{(@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)}     \\
          &\coqM{{@$\alpha_1$@ @$\ldots$@ @$\alpha_m$@ : Type}}           \\
          &\coqM{(@$x_1'$@ : @$\toCoqX{\tau_1}$@) @$\ldots$@ (@$x_n'$@ : @$\toCoqX{\tau_n}$@)}                                           \\
          &\coqM{: @$\toCoqX{\tau}$@}                                     \\
          &\coqM{:= @$\toCoqX{e}$@.}                                      \\
      \end{array}
  \]
  \caption{
    Translation rule for a $n$-ary polymorphic function declaration with $m$ type variables.
    The types $\tau_1$ through $\tau_n$ are the types of the variables $x_1$ through $x_n$, respectively.
  }
  \label{fig:translation:func-decl:non-rec}
\end{figure}

However, in general the type signature does not necessarily have that format.
This is because the type signature could contain type synonyms.
Consider for example the following function declaration.
\begin{minted}{haskell}
  type Predicate a = a -> Bool

  nonZero :: Predicate Integer
  nonZero n = n /= 0
\end{minted}
To determine the type of \haskell{n} as well as the return type of \haskell{nonZero}, we need to expand the type synonym \haskell{Predicate Integer}.
Not all type synonyms need to be expanded though.
Our current approach suffices to determine the argument and return types the following two functions.
\begin{minted}{haskell}
  testZero :: Predicate Integer -> Bool
  testZero p = p 0

  greaterThan :: Integer -> Predicate Integer
  greaterThan n = (> n)
\end{minted}

The rule shown in \autoref{fig:translation:func-decl:non-rec:expansion} expands only those type synonyms that need to be expanded in order to determine the type of an argument.
In the example above, $\toCoq{}$ would expand the type of \haskell{nonZero} to \haskell{Integer -> Bool} but leaves the type of both \haskell{testZero} and \haskell{greaterThan} unchanged.

\begin{figure}[H]
  \begin{align*}
    \toCoq{\left(
      \begin{array}{l}
        \haskellM{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_i$@ -> @$S$@ @$\kappa_1$@ @$\ldots$@ @$\kappa_m$@} \\
        \haskellM{@$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@}
      \end{array}
    \right)}
    = \toCoq{\left(
      \begin{array}{l}
        \haskellM{@$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_i$@ -> @$\sigma(\kappa)$@} \\
        \haskellM{@$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@}
      \end{array}
    \right)}
    &&\forall i < n
  \end{align*}
  \caption{
    A demand driven approach to the expansion of type synonyms in $n$-ary function declarations.
    We assume that there is type synonym declaration \haskell{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_m$@ = @$\kappa$@}.
    For the expansion of $S$ we apply the substitution $\sigma = \{\, \alpha_1 \mapsto \kappa_1, \ldots, \alpha_m \mapsto \kappa_m \,\}$.
  }
  \label{fig:translation:func-decl:non-rec:expansion}
\end{figure}

\subsection{Translation of Recursive Functions}
If we tried to apply the translation rule for non-recursive function declarations to the declaration of a recursive function like \haskell{append} (as defined in the listing below), Coq would complain that there is no such function when it encounters the recursive call to \haskell{append}.
\begin{minted}{haskell}
  append :: [a] -> [a] -> [a]
  append xs ys = case xs of
    []      -> ys
    x : xs' -> x : append xs' ys
\end{minted}
This is because \coq{Definition} sentences are not allowed to reference themselves in Coq.
If they were allowed to do so, it would be possible to define a non-terminating function.
The following is allowed in Haskell for example.
\begin{minted}{haskell}
  loop :: a
  loop = loop
\end{minted}
Similar to \haskell{undefined}, \haskell{loop} is a polymorphic value.
In much the same way as shown for \haskell{undefined} in \autoref{sec:translation:expr:errors}, \haskell{loop} could therefore be used to proof arbitrary propositions when translated to Coq.
Nevertheless, recursion is an important aspect of functional programming languages and most recursive functions also terminate eventually.
In order to still allow recursion, Coq needs to ensure that recursive functions terminate on all inputs.
To indicate that this check needs to be performed by Coq, the user has to explicitly annotate a recursive function as such.
Instead of a \coq{Definition} sentence, a \coq{Fixpoint} sentence is used in this case.
The following non-lifted implementation of \coq{append} would be accepted by Coq for example.
\begin{minted}{coq}
  Fixpoint append {a : Type} (xs : list a) (ys : list a) : list a
    := match xs with
       | nil        => ys
       | cons x xs' => cons x (append xs' ys)
       end.
\end{minted}
To check that functions like \coq{append} actually terminate, Coq carries out a syntactic analysis of the \coq{Fixpoint} sentence.
Namely, Coq must be able to recognize that the function \textit{decreases} on one of its arguments.
We say that a \coq{Fixpoint} sentence \coq{Fixpoint @$f$@ (@$x_1$@ : @$\tau_1$@) @$\ldots$@ (@$x_1$@ : @$\tau_1$@) : @$\tau$@ := @$e$@.} decreases on $x_i$ if the $i$-th argument of every recursive call to $f$ in $e$ is \textit{structurally smaller} than the original argument $x_i$ \cite[p.~111]{CoqDevTeam:2018}.
One source of structurally smaller terms is pattern matching.
If pattern matching is performed on the decreasing argument or a structurally smaller term, the variables in the patterns are structurally smaller than the decreasing argument themselves.
In the example above, \coq{append} is decreasing on its first explicit argument, i.e., \coq{xs}.
This is because in the only recursive call \coq{append xs' ys} the first argument, i.e., \coq{xs'}, is bound to a subterm of \coq{xs} by the means of pattern matching.

Although Coq's termination checker uses an even more sophisticated ruleset to determine whether a term is structurally smaller than another, it rejects the lifted version of \coq{append} that the translation rule in \autoref{fig:translation:func-decl:non-rec} would produce if we simply swapped \coq{Definition} for \coq{Fixpoint}.
\begin{minted}{coq}
  Fixpoint append (@$\Shape$@ : Type) (@$Pos$@ : @$\Shape$@ -> Type) {a : Type}
                  (xs : @$\toCoq{[a]}$@) (ys : @$\toCoq{[a]}$@) : @$\toCoq{[a]}$@
    := xs >>= (fun xs_0 =>
         match xs_0 with
         | nil        => ys
         | cons x xs' => Cons @$\Shape$@ @$Pos$@ x (append xs' ys)
         end).
\end{minted}
The definition is rejected because this time \coq{xs'} is not a direct subterm of \coq{xs} but of \coq{xs_0}.
That the \coq{>>=} operator is implemented in such a way that \coq{xs_0} is always bound to a subterm of \coq{xs} is not checked by Coq.
This is a limitation of the heuristic employed by Coq's termination checker without any particular theoretical justification \cite[p.~62]{Chlipala:2013}.
As the \textit{halting problem} is undecidable, it is natural that there are always situations like this, where the termination checker cannot guess the decreasing argument.
In this concrete situation, the problem results from the usage of a \textit{nested inductive type}.
Lets first recall the definition of the monadically lifted \coq{List} type from \autoref{sec:translation:type-decl:rec}.
\begin{minted}[highlightlines={3}]{coq}
  Inductive List (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
    := nil  : List @$\Shape$@ @$\Pos$@ a
     | cons : Free @$\Shape$@ @$\Pos$@ a -> Free @$\Shape$@ @$\Pos$@ (List @$\Shape$@ @$\Pos$@ a) -> List @$\Shape$@ @$\Pos$@ a.
\end{minted}
The \coq{List} type is called a nested inductive type because in the second argument of the \coq{cons} constructor the type \coq{List @$\Shape$@ @$\Pos$@ a} occurs \textit{nested} inside the type constructor \coq{Free @$\Shape$@ @$\Pos$@} \cite[p.~29]{Dylus:2018}.

As described by \cite{Dylus:2018}, we can work around the restriction of Coq's termination checker concerning nested inductive types by transform the recursive function such that it resembles the nested structure of the decreasing argument's data type.
For this purpose, the original function is splitted into a recursive helper function and a non-recursive main function.
The helper function, must be defined such that its decreasing argument is not lifted to the free monad.
In case of \coq{append}, the fact that the helper function \coq{append'} expects a non monadic argument means that \coq{append'} cannot be invoked before the bind operation has been performed.
Therefore, the main function for \coq{append} looks as follows if we insert the call to the helper function as soon as possible.
\begin{minted}{coq}
  Definition append (@$\Shape$@ : Type) (@$Pos$@ : @$\Shape$@ -> Type) {a : Type}
                  (xs : @$\toCoq{[a]}$@) (ys : @$\toCoq{[a]}$@) : @$\toCoq{[a]}$@
    := xs >>= (fun xs_0 => append' xs_0 ys).
\end{minted}
The body of the helper function now has to contain the \coq{match} term that we replaced by the call to \coq{append'} above.
\begin{minted}{coq}
  match xs_0 with
  | nil        => ys
  | cons x xs' => Cons @$\Shape$@ @$Pos$@ x (append xs' ys)
  end
\end{minted}
However, because \coq{append'} must be defined before \coq{append}, \coq{append'} cannot reference \coq{append}.
We can solve this problem by inlining the definition of \coq{append} into \coq{append'}.
\begin{minted}{coq}
  Fixpoint append' (@$\Shape$@ : Type) (@$Pos$@ : @$\Shape$@ -> Type) {a : Type}
                   (xs : @$\toCoqT{[a]}$@) (ys : @$\toCoq{[a]}$@) : @$\toCoq{[a]}$@
    := match xs_0 with
       | nil        => ys
       | cons x xs' => Cons @$\Shape$@ @$Pos$@ x (xs' >>= (fun xs'_0 => append' xs'_0 ys))
       end.
\end{minted}
This pair of definitions is now accepted by Coq's termination checker.
Most importantly though, the transformation also does not change the behaviour of \coq{append}.
Intuitively, this is the case because we perform a bind only when the original definition would also have performed a bind.
% TODO worker/wrapper transformation?

Next, we want to generalize the approach outlined above.
Since function declaration can be mutually recursive, we have to consider entire strongly connected components of the dependency graph again.
In summary, the following steps need to be performed for the translation.

\begin{enumerate}
  \item
  Determine the decreasing argument of all function declarations in the strongly connected component.
  \item
  Split the functions into helper and main functions.
  \item
  Inline the definition of the main functions into the helper functions.
  \item
  Translate all helper functions to a single joined \coq{Fixpoint} sentence and the main functions into individual \coq{Definition} sentences.
\end{enumerate}

For the remainder of this section, we are going to sort out the details of those steps.
Of particular interest are steps 1 and 2.

\paragraph{Determining Decreasing Arguments}
We have seen a simplified description of the algorithm used by Coq to test whether a function is decreasing on a specific argument earlier.
We are going to use the same simplified version of that algorithm.
Of course, that means that we can only translate a subset of all recursive functions that Coq would be able to accept.
However, reimplementing the entire termination checker of Coq is beyond the scope of this thesis.

To determine the decreasing argument of a function declaration, we have to test for every argument of the function declaration whether the function is decreasing on this argument.
This cannot be done independently for each function declaration, because the choice of a decreasing argument influences which arguments of another function are decreasing.
Consider two mutually recursive binary functions \haskell{foo} and \haskell{bar}, where \haskell{foo}'s implementation looks something like this.
\begin{minted}{haskell}
  foo x y = case x of
    C x' -> case y of
      C y' -> bar x' y'
\end{minted}
If \haskell{bar} is decreasing on its first argument, then \haskell{foo} is also decreasing on its first argument.
Conversely, if \haskell{bar} does not decrease on its first argument, then \haskell{x} is also an invalid choice for the decreasing argument of \haskell{foo}.
Therefore, we have to consider every possible combination of decreasing arguments and test whether all functions in the strongly connected actually decrease on those arguments.

\paragraph{Splitting into Helper and Main Functions}
Unlike in the example of \coq{append}, we are going to perform the transformation of the original function into a helper and main function before the conversion to Coq.
Another way in which the general case differs from the example is that the generation of a single helper function may not suffice.
This is because the call to the helper function cannot be inserted before the decreasing argument has been bound for the first time.
A bind operator is inserted when translating \haskell{case} or \haskell{if} expressions or when invoking a function.
As the decreasing argument must be inductively defined, the decreasing argument cannot be a function and will therefore never be invoked.
Even though it would be possible for the decreasing argument to be bound by an \haskell{if} expression, decreasing on a boolean value is not plausible in the first place.
Therefore, the only way for a decreasing argument to be bound is when pattern matching is performed on the decreasing argument.
As there can be multiple such \haskell{case} expressions, one helper function must be generated for each of them.
For example, two helper functions must be generated for the following function: one for the \haskell{case} expression in the \haskell{then} branch and one for the other in the \haskell{else} branch.

\begin{center}
  \begin{minipage}[t]{0.3\textwidth}
    \begin{minted}{haskell}
      @$f$@ :: @$\tau_1$@ -> @$\tau_2$@
      @$f$@ x = if @$...$@
        then case x of @$...$@
        else case x of @$...$@
    \end{minted}
  \end{minipage}
  \begin{minipage}[c]{0.1\textwidth}
    $\mathlarger{\mathlarger{\mathlarger{\rightsquigarrow}}}$
  \end{minipage}
  \begin{minipage}[t]{0.35\textwidth}
    \begin{minted}{haskell}
      @$f$@, @$f_1$@, @$f_2$@ :: @$\tau_1$@ -> @$\tau_2$@
      @$f$@ x = if @$...$@ then @$f_0$@ x else @$f_1$@ x
      @$f_0$@ x = case x of @$...$@
      @$f_1$@ x = case x of @$...$@
    \end{minted}
  \end{minipage}
\end{center}

If the \haskell{if} expression would have been a \haskell{case} expression itself, the generation of the helper functions would further be complicated by the fact that the inner \haskell{case} expressions could reference variable patterns from the outer \haskell{case} expression.
The is true when the \haskell{case} expression is wrapped by a lambda abstraction.
For this reason, additional arguments may have to be added to the generated helper functions.

\begin{center}
  \begin{minipage}[t]{0.3\textwidth}
    \begin{minted}{haskell}
      @$f$@ x = case @$...$@ of
        @$C_1$@ y   -> case x of @$...$@
        @$C_2$@ y z -> case x of @$...$@
    \end{minted}
  \end{minipage}
  \begin{minipage}[c]{0.1\textwidth}
    $\mathlarger{\mathlarger{\mathlarger{\rightsquigarrow}}}$
  \end{minipage}
  \begin{minipage}[t]{0.35\textwidth}
    \begin{minted}{haskell}
      @$f$@ x = case @$...$@ of
        @$C_1$@ y   -> @$f_1$@ x y
        @$C_2$@ y z -> @$f_2$@ x y z
      @$f_1$@ x y   = case x of @$...$@
      @$f_2$@ x y z = case x of @$...$@
    \end{minted}
  \end{minipage}
\end{center}

Furthermore, we neither know the return type of the generated helper functions nor the types of the additional arguments.
For example, consider a function \haskell{@$g$@ :: @$\kappa$@ -> @$\tau$@}.
If a call to $g$ wraps the \haskell{case} expression, the corresponding helper function must produce a value of type $\kappa$.
However, due to a lack of type inference we do not know $\kappa$.
\begin{center}
  \begin{minipage}[t]{0.3\textwidth}
    \begin{minted}{haskell}
      @$f$@ :: @$\tau_1$@ -> @$\tau$@
      @$f$@ x = g (case x of @$...$@)
    \end{minted}
  \end{minipage}
  \begin{minipage}[c]{0.1\textwidth}
    $\mathlarger{\mathlarger{\mathlarger{\rightsquigarrow}}}$
  \end{minipage}
  \begin{minipage}[t]{0.35\textwidth}
    \begin{minted}{haskell}
      @$f$@ :: @$\tau_1$@ -> @$\tau$@
      @$f$@ x = g (@$f_1$@ x)
      @$f_1$@ :: @$\tau_1$@ -> @$\kappa$@
      @$f_1$@ x = case x of @$...$@
    \end{minted}
  \end{minipage}
\end{center}

As suggested by the examples above, formalizing the process of splitting recursive functions is more technical compared to all translation rules we have seen so far.
The splitting procedure involves the following steps.

\begin{enumerate}
  \item
  Consider a $n$-ary recursive function declaration $f$ that decreases on its $i$-th argument.
  \begin{minted}{haskell}
     @$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@
     @$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@
  \end{minted}
  If necessary, expand type synonyms in the type signature of $f$ as shown in \autoref{fig:translation:func-decl:non-rec:expansion}.

  \item
  Find a position $p \in Pos(e)$ of a \haskell{case} expression for the decreasing argument.
  \[
    \subterm{e}{p} = \haskellM{case @$x_i$@ of @$alts_p$@}
  \]

  The selected case expression must not be nested inside another \haskell{case} expression for the decreasing argument.
  \[
    \forall q < p \colon \subterm{e}{q} \ne \haskellM{case @$x_i$@ of @$alts_q$@}
  \]

  \item
  Determine the additional parameters $y_1, \ldots, y_m$ that need to be added to the corresponding helper function.
  A variable must be added as an additional parameter if it is bound by a surrounding \haskell{case} expression or lambda abstraction and occurs freely in $\subterm{e}{p}$.

  \item
  Generate a helper function $f_p$ and replace the \haskell{case} expression in the original function by a call to the helper function.
  \begin{center}
    \begin{minipage}[t]{0.3\textwidth}
      \begin{minted}{haskell}
        @$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@
        @$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$e$@
      \end{minted}
    \end{minipage}
    \begin{minipage}[c]{0.05\textwidth}
      $\mathlarger{\mathlarger{\mathlarger{\rightsquigarrow}}}$
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \begin{minted}{haskell}
        @$f$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\tau$@
        @$f$@ @$x_1$@ @$\ldots$@ @$x_n$@ = @$\replaceSubterm{e}{f_p\;x_1\;\ldots\;x_n\;y_1\;\ldots\;y_m}{p}$@
        @$f_p$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\kappa_1$@ -> @$\ldots$@ -> @$\kappa_m$@ -> @$\kappa$@
        @$f_p$@ @$x_1$@ @$\ldots$@ @$x_n$@ @$y_1$@ @$\ldots$@ @$y_m$@ = @$\subterm{e}{p}$@
      \end{minted}
    \end{minipage}
  \end{center}
  Where $\kappa_1, \ldots, \kappa_m$ denote the unknown types of the additional parameters $y_1, \ldots, y_m$, respectively, and $\kappa$ denotes the unknown return type of the generated helper function.

  \item
  If there are more \haskell{case} expressions for the decreasing argument, go to step 2.
  Otherwise, we are done.
\end{enumerate}

After all function declarations in the strongly connected component have been splitted into helper and main functions, the definitions of the main functions need to be inlined into the helper functions.
It does not suffice to inline the main function into the helper functions that were generated from the same original function only.

\paragraph{Conversion to Coq}
In the last step, the generated main and helper functions need to be converted to Coq.
Since the main functions are not recursive anymore, they can be translated to \coq{Definition} sentences as shown in \autoref{fig:translation:func-decl:non-rec}.
The order of the main functions does not matter, as all calls to other functions in the strongly connected component must be subterms of the \haskell{case} expressions captured by the helper functions.

The helper functions on the other hand remain mutually recursive.
Thus, they need to be translated into a single \coq{Fixpoint} sentence.
\autoref{fig:translation:func-decl:rec} shows the translation of a single helper function to a \coq{Fixpoint} sentence.
If there are multiple helper functions, the individual \coq{Fixpoint} sentences can be concatenated using the \coq{with} keyword just as with \coq{Inductive} sentences.
To make sure that Coq does not guess a different decreasing argument, we explicitly mark the decreasing argument with a \coq{{@\aspellIgnore{@struct@}@ @$x$@}} annotation.

\begin{figure}[H]
  \begin{align*}
    &\toCoq{\left(\begin{array}{l}
      \haskellM{@$h$@ :: @$\tau_1$@ -> @$\ldots$@ -> @$\tau_n$@ -> @$\kappa_1$@ -> @$\ldots$@ -> @$\kappa_p$@ -> @$\kappa$@} \\
      \haskellM{@$h$@ @$x_1$@ @$\ldots$@ @$x_n$@ @$y_1$@ @$\ldots$@ @$y_p$@ = case @$x_i$@ of @$e$@}
    \end{array}\right)}
    \\
    &\qquad\qquad\qquad=
    \begin{array}{ll}
      \coqM{Fixpoint @$h'$@}
        &\coqM{(@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) {@$\alpha_1$@ @$\ldots$@ @$\alpha_m$@ : Type}} \\
        &\coqM{(@$x_1'$@ : @$\toCoqX{\tau_1}$@) @$\ldots$@ (@$x_i'$@ : @$\toCoqTX{\tau_i}$@) @$\ldots$@ (@$x_n'$@ : @$\toCoqX{\tau_n}$@)} \\
        &\coqM{@$y_1'$@ @$\ldots$@ @$y_p'$@ {struct @$x_i'$@} :=}\;\toCoq{(\haskellM{case @$x_i$@ of @$e$@})}\coqM{.}  \\
    \end{array}
  \end{align*}
  \caption{
    Translation rule for a single helper function $h$ that is decreasing on its $i$-th argument.
    $y_1, \ldots, y_p$ are the additional parameters of unknown type $\kappa_1, \ldots, \kappa_p$.
    The return type $\kappa$ of the helper function is also not known and must be inferred by Coq.
    The decreasing argument $x_i$ is not lifted into the free monad.
  }
  \label{fig:translation:func-decl:rec}
\end{figure}

\subsection{Translation of Partial Functions}
The translation of error terms show in \autoref{fig:translation:expr:error} required an instance of the \coq{Partial} type class for $Shape$ and $Pos$ to be available in the current context.
In Haskell it would suffice to have a \haskell{instance} declaration in the current module or import a module that contains such a declaration.
\begin{minted}{haskell}
  instance Partial (Maybe a) where
    undefined  = Nothing
    error _msg = Nothing
\end{minted}
When \haskell{undefined} is used in a place where a value of type \haskell{Maybe a} is expected, Haskell would automatically use the implementation of \haskell{undefined} from the type class instance above.
In Coq, however, type class instances must be passed as arguments to functions, similar to how type arguments are passed to functions as well.
Thus, if a function contains an error term, i.e., invokes \haskell{undefined} or \haskell{error}, then the function must have an additional argument for the \coq{Partial} type class instance.
For example, \haskell{head} needs a \coq{Partial} instance when converted to Coq.
Therefore, we add another explicit parameter after $Shape$ and $Pos$.
\[
  \toCoq{\left(\begin{array}{l}
    \haskellM{head :: [a] -> a}           \\
    \haskellM{head xs = case xs of}       \\
    \quad\haskellM{[]      -> undefined} \\
    \quad\haskellM{x : xs' -> x}         \\
  \end{array}\right)}
  = \begin{array}{ll}
    \coqM{Definition head}\;
      &\coqM{(@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)} \\
      &\coqM{(@$P$@ : Partial @$\Shape$@ @$\Pos$@) {a : Type}}    \\
      &\coqM{(xs : @$\toCoqX{[a]}$@) : @$\toCoqX{[a]}$@ := (* ... *).}
  \end{array}
\]
In consequence, every function that uses \haskell{head} also needs a \coq{Partial} instance in order to invoke \haskell{head}.
If we consider \haskell{error} and \haskell{undefined} to be normal functions, we can use the dependency graph to determine which functions need to be equipped with a \coq{Partial} instance: if there is a directed path from a function to the nodes of the dependency graph that correspond to \haskell{error} or \haskell{undefined}, a parameter for the \coq{Partial} instances must be added.
In case of recursive functions, the main and main and helper functions need a \coq{Partial} instance if and only if the original function needs a \coq{Partial} instance.
Hereinafter, we will refer to functions that take a \coq{Partial} instance as a parameter as \textit{partial functions}.

The only change to the existing translation rules in \autoref{fig:translation:func-decl:non-rec} \autoref{fig:translation:func-decl:rec} is that the parameter \coqM{(@$P$@ : Partial @$\Shape$@ @$\Pos$@)} is added after $Shape$ and $Pos$ if the declared function is partial.
Additionally, we have to revise the translation rule for the application of defined functions from \autoref{fig:translation:expr:fun_app}.
If the function is partial, the type class instance $P$ must be passed after $Shape$ and $Pos$ as shown in \autoref{fig:translation:func-decl:partial_app}.
\begin{figure}[H]
  \begin{align*}
    \toCoq{(f\;e_1\;\ldots\;e_n)} = f'\;\Shape\;\Pos\;P\;\toCoq{e_1}\;\ldots\;\toCoq{e_n}
  \end{align*}
  \caption{Translation rule for the full application of a $n$-ary partial function $f$.}
  \label{fig:translation:func-decl:partial_app}
\end{figure}

Lastly, note that higher-order functions are not required to be partial, even though a function that is passed to them could be partial.
For example, \haskell{map} does not require a \coq{Partial} instance.
The only function invoked by \haskell{map} except for itself is the function passed as its first argument.
\begin{minted}{haskell}
  map :: (a -> b) -> [a] -> [b]
  map f xs = case xs of
    []      -> []
    x : xs' -> f x : map f xs'
\end{minted}
If we try to plug a partial function like \haskell{head} into \haskell{map}, \haskell{head} is equipped with the \coq{Partial} instance at call-time already.
\[
  \toCoq{(\haskellM{map head xss})}
  =
  \coqM{map (fun xs => head @$Shape$@ @$Pos$@ @$P$@ xs) xss}
\]
Therefore, there is no need for \haskell{map} to know about the \coq{Partial} instance.
