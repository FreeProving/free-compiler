\section{Architecture} \label{sec:implementation:architecture}
The Haskell to Coq compiler presented in this thesis is written in Haskell itself.
To manage dependencies and to build the compiler, we are using Cabal\footnote{\url{https://www.haskell.org/cabal/}}.
Instructions for how to setup, build and run the compiler can be found in \autoref{appendix:usage}.

The compilation process for the translation of a Haskell module to Coq is outlined in \autoref{fig:implementation:architecture}.
First, Haskell files are parsed into a data structure known as an \textit{abstract syntax tree} ("AST").
In the second stage, the AST is converted to an intermediate representation that simplifies the analysis and conversion of the Haskell program in the subsequent stages.
The converter transforms the simplified Haskell AST to a Coq AST that is printed to the console or output file in the final stage of the compilation process.

\begin{figure}[p]
  \digraph[scale=0.75]{CompielerArchitecture}{
    node [shape = "rect", width = 2];

    input  [label = "Haskell Source File", color = "white"];
    parser [label = "Parser"];
    simplifier [label = "Simplifier"];
    deps_analysis [label = "Dependency Analysis"];
    partial_analysis [label = "Partiality Analysis"];
    pretty_printer [label = "Pretty Printer"];
    type_conversion [label = "Type Conversion"];
    func_conversion [label = "Function Conversion"];
    output [label = "Coq Source File", color = "white"];

    input            -> parser;
    parser           -> simplifier        [label = "  Haskell AST"];
    simplifier       -> deps_analysis     [label = "  Simplified AST"];
    deps_analysis    -> partial_analysis;
    partial_analysis -> type_conversion;
    type_conversion  -> func_conversion;
    func_conversion  -> pretty_printer    [label = "  Coq AST"];
    pretty_printer   -> output;
  }
  \caption{
    Stages of the compilation process from Haskell to Coq.
    Arrows are labeled with the intermediate representation of the data passed between two stages.
  }
  \label{fig:implementation:architecture}
\end{figure}

Using Haskell for the implementation of our compiler allows us to make use of Haskell's package infrastructure.
Especially, the Haskell and Coq parsers, ASTs and pretty printers have not been implemented by ourselves.
In the following sections more details will be given regarding the individual stages and used libraries.
