\section{Dependency Analysis} \label{sec:implementation:dependency-analysis}
Since the order of declarations matters in Coq, we have to group and sort type and function declarations according to their dependencies.
As has been described in \autoref{chp:translation} already, a dependency graph has to be created for this purpose.
Declarations whose nodes are in the same strongly connected connected component of the dependency graph, must be converted at the same time and the strongly connected components have to be converted in reverse topological order.
Fortunately, there are libraries in Haskell to work with graphs, so we do not have to implement any of those algorithms on our own.
Specifically, we are using the  \haskell{Data.Graph}\footnote{\url{http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html}} module from the \texttt{containers} package to handle dependency graphs.

Using the \haskell{stronglyConnComp} function from \haskell{Data.Graph} one can directly obtain a list of strongly connected components in reverse topological order.
To use \haskell{stronglyConnComp} we have to represent dependency graphs as a list of triples where each triple represents a node of the dependency graph and has the following components:
\begin{itemize}
  \item the AST node that corresponds the respective node of the dependency graph,
  \item the name of the of the type or function declaration and
  \item a list of names for types and functions used by the declaration.
\end{itemize}
Thus, the only part of the dependency analysis that we have to implement ourselves is the extraction of used types and functions of the declarations.
For simplicity, we consider type and function declarations independently, i.e., we are creating two separate dependency graphs for one for type declarations and one for functions.
We can ignore dependencies between functions and types as all converted type declarations are placed in front of all function declarations later anyway.

The extraction of a \haskell{type} declaration's dependencies is governed by the following rules for example where $\delta$ denotes a function that computes the set of used identifiers for a given Haskell language construct.
\begin{align*}
  \delta(\haskellM{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@})
    &= \delta(\tau)
      \setminus \{\, \alpha_1, \ldots, \alpha_n \,\}
  \\
  \\
  \delta(\tau_1 \rightarrow \tau_2) &= \delta(\tau_1) \cup \delta(\tau_2) \\
  \delta(\tau_1\;\tau_2)            &= \delta(\tau_1) \cup \delta(\tau_2) \\
  \delta(T)                         &= \{\, T \,\} \\
  \delta(\alpha)                    &= \{\, \alpha \,\}
\end{align*}
Similar rules are implemented for data type declarations, function declarations and expressions as well.
