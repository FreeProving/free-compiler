\section{Notation} \label{sec:translation:notation}
\subsection{Notation for Translation Rules}
The translation rules presented in this chapter are based on the work by \cite{Abel:2005}.
We are also going to adopt their notation and write
\[
  \toCoq{H} = G
\]
to express that the Haskell language construct $H$ (e.g., a type, expression or declaration) should be converted to the corresponding Gallina language construct $G$ (e.g., a term or sentence).

\subsection{Naming conventions}
In the translation rules we make extensive use of meta-variables for identifiers, expressions or types.
For the sake of readability, those meta-variables will not always be introduced explicitly.
Instead, we rely on naming conventions outlined in this section to determine what the meta-variables stands for.
If there are multiple meta-variables of the same kind, we use a subscripted index.

The symbols $\tau$, $T$, $\alpha$ are used as identifiers for type expressions, constructors and variables, respectively.
Instead of $\tau$, we also use $\kappa$ for type expressions in some places.
Data type and type synonym declarations will usually be named $D$ or $S$.
Analogously $e$, $C$ and $x$ are used for expressions, constructors and variables.
Alternatively, $y$ is used for variables as well.
Function declarations are called $f$ by convention.
We use $\circ$ for infix operators.
A lower case $c$ is used for the name of a data constructor in Coq.
The lower case $c$ should differ from the corresponding capital $C$ only in that its first letter is converted to lower case.
E.g. if $C_i = \texttt{Foo}$ for some index $i$, then $c_i$ will be \coq{foo}.

We are also using $\Shape$ and $\Pos$ as identifiers for the arguments of the free monad.
They are passed explicitly as parameters to generated Coq sentences.

\subsection{Notation for renamed identifiers}
Not all Haskell identifiers are valid Coq identifiers and need to be renamed if necessary.
For example \haskell{with} could be used in Haskell as the name for a function or variable, but not in Coq as \haskell{with} is a keyword in Coq.

Similarly, Haskell allows types and constructors to have the same name because their namespaces are separated.
Since Coq is a dependently typed language, types in Coq can contain values.
Therefore, Coq constructors can conflict with types of the same name and need to be renamed as well.

Details on how identifiers are renamed will be given in \autoref{chp:implementation}.
In this chapter we will simply write $I'$ for the renamed version of a Haskell identifier $I$.
For short, we write $e'$ or $\tau'$ for an expression $e$ or type expressions $\tau$ in which all identifiers have been renamed appropriately.
