\section{Modeling Ambient Effects in Coq} \label{sec:preliminaries:modeling-effects}
Since Haskell is a purely functional programming language, computations are not allowed to have any implicit side-effects.
Therefore, all interactions with the environment need to be performed explicitly within the \haskell{IO} monad.
However, the evaluation of certain expressions can still implicitly cause an effect in Haskell.
For example, the evaluation of a call to \haskell{error} or \haskell{undefined} causes the program to terminate immediately \cite[p.~16]{Marlow:2010}.
Similarly, the \haskell{trace} function provided by the \haskell{Debug.Trace} module from Haskell's \texttt{base} library prints a message to the console for debugging purposes.
Such \textit{ambient effects} \citep{Christiansen:2019} are not supported by Coq.
In this section we present the approach implemented by our compiler to model the ambient effects of translated Haskell programs in Coq.

\subsection{Monadic Translation} \label{sec:preliminaries:modeling-effects:monadic-translation}
Due to the totality requirement of Coq, the function \haskell{head} cannot be expressed directly within Coq.
When we try to implement \haskell{head} in Coq, we get stuck in the case for the empty list as indicated by the three question marks in the left listing below.

\begin{tabular}{p{0.40\linewidth} | p{0.55\linewidth}}
  \begin{minted}{haskell}
    head :: [a] -> a
    head xs = case xs of
      []      -> undefined
      x : xs' -> x
  \end{minted}
  &
  \begin{minted}{coq}
    Definition head (X : Type) (xs : list X) : X
      := match xs with
         | nil        => (* ??? *)
         | cons x xs' => x
         end.
  \end{minted}
\end{tabular}

However, the same idea used by Haskell to model side-effects using the \haskell{IO} monad can be applied to model partiality in Coq.
Namely, we can use the \haskell{Maybe} monad, to express that the computation of \haskell{head} does not return a value for some inputs.
The \haskell{Maybe} data type is known as \coq{option} in Coq.
The constructors \haskell{Nothing} and \haskell{Just} from \haskell{Maybe} correspond to \coq{option}'s constructors \coq{None} and \coq{Some}, respectively.
By lifting the return value of \haskell{head} into the \haskell{Maybe} monad, we can now implement the function in Coq as well.

\begin{tabular}{p{0.40\linewidth} | p{0.55\linewidth}}
  \begin{minted}{haskell}
    head :: [a] -> Maybe a
    head xs = case xs of
      []      -> Nothing
      x : xs' -> Just x
  \end{minted}
  &
  \begin{minted}{coq}
    Definition head (X : Type) (xs : list X) : option X
      := match xs with
         | nil        => None
         | cons x xs' => Some x
         end.
  \end{minted}
\end{tabular}

Lifting just the return value of functions is not enough, though.
Due to Haskell's lazy evaluation strategy, the evaluation of the argument of a function can be effectful as well.
Consider for instance a list of lists \haskell{xss} and the expression \haskell{head (head xss)} which computes the first element of the first list in \haskell{xss}.
If \haskell{xss} is empty, the inner call to \haskell{head} fails.
However, Haskell will not terminate until the evaluation of this inner call is requested by the evaluation of the \haskell{case} expression in the outer call.
To model effects in arguments, the argument type needs to be lifted as well.
In consequence, we have to consider the additional case that the given argument represents a runtime error, i.e., is \haskell{Nothing}.

\begin{tabular}{p{0.40\linewidth} | p{0.55\linewidth}}
  \begin{minted}{haskell}
    head :: Maybe [a] -> Maybe a
    head mxs = case mxs of
      Nothing        -> Nothing
      Just ([]     ) -> Nothing
      Just (x : xs') -> Just x
  \end{minted}
  &
  \begin{minted}{coq}
    Definition head (X : Type) (mxs : option (list X))
      : option X
      := match mxs with
         | None              => None
         | Some (nil       ) => None
         | Some (cons x xs') => Some x
         end.
  \end{minted}
\end{tabular}

Since \haskell{Maybe} is a monad, we can use the bind operator instead.
The bind operator unwraps the value stored within the monad, applies the given operation on the value and handles the absence of a value appropriately.

\begin{tabular}{p{0.40\linewidth} | p{0.55\linewidth}}
  \begin{minted}{haskell}
    head :: Maybe [a] -> Maybe a
    head mxs = mxs >>= \xs ->
      case xs of
        []      -> Nothing
        x : xs' -> Just x
  \end{minted}
  &
  \begin{minted}{coq}
    Definition head (X : Type) (mxs : option (list X))
      : option X
      := mxs >>= (fun xs => match xs with
         | nil        => None
         | cons x xs' => Some x
         end).
  \end{minted}
\end{tabular}

Similarly, the values inside of the list can be effectful as well.
For example, the call \haskell{head [undefined]} should return \haskell{Nothing} in the lifted variant.
However, the return value of \haskell{head} is always wrapped by \haskell{Just} in the example above.
Therefore, we have to remove the \haskell{Just} constructor and lift the list's value type to the \haskell{Maybe} monad.
While the type \haskell{Maybe [Maybe a]} would be sufficient to model a list like \haskell{[1, undefined, 2]}, it fails to represent \haskell{1 : undefined} since the second argument of \haskell{(:)} is not lifted to the \haskell{Maybe} monad.
In consequence, we have to update the declaration of the list data type to lift all arguments of all constructors.

\begin{tabular}{p{0.40\linewidth} | p{0.55\linewidth}}
  \begin{minted}{haskell}
    data List a
      = Nil
      | Cons (Maybe a) (Maybe (List a))
  \end{minted}
  &
  \begin{minted}{coq}
    Inductive list (X : Type) : Type
      := nil  : list X
      |  cons : option X
                -> option (list X)
                -> list X.
  \end{minted}
\end{tabular}

Finally, the \haskell{head} function can now be implemented as follows.

\begin{tabular}{p{0.40\linewidth} | p{0.55\linewidth}}
  \begin{minted}{haskell}
    head :: Maybe (List a) -> Maybe a
    head mxs = mxs >>= \xs ->
      case xs of
        Nil          -> Nothing
        Cons mx mxs' -> mx
  \end{minted}
  &
  \begin{minted}{coq}
    Definition head (X : Type) (mxs : option (list X))
      : option X
      := mxs >>= (fun xs => match xs with
         | nil          => None
         | cons mx mxs' => mx
         end).
  \end{minted}
\end{tabular}

The process of lifting argument and return types of functions as well as the arguments of constructors, as shown above, is known as a \textit{monadic translation} of the program.
\cite{Abel:2005} present a monadic translation from Haskell programs to Agda.
Based on their translation rules, \cite{Jessen:2019} developed a prototype for a compiler that monadically translates Haskell programs to Coq.

Note that except for the representation of \haskell{undefined} as \haskell{Nothing}, the definitions above are completely independent of the \haskell{Maybe} and \coq{option} data types, i.e., we can simply swap the \haskell{Maybe} monad for another monad to model other effects.
The implementation by \cite{Jessen:2019} supports the \haskell{Identity} monad, for example, for the translation of total programs.
In Haskell we could now generalize our definitions to work with any monad by adding an additional type parameter.
For instance, the listing below shows the list data type lifted to an arbitrary monad with type constructor \haskell{m}.

\begin{minted}{haskell}
  data List m a = Nil | Cons (m a) (m (List m a))
\end{minted}

In Coq this generalization would allow us to proof properties of functions that hold regardless of the effect.
However, it is not possible to simply add this type parameter to the list data type in Coq.

\begin{minted}{coq}
  Fail Inductive list (M : Type -> Type) (X : Type) : Type
    := nil  : list M X
    |  cons : M X -> M (list M X) -> list M X.
\end{minted}

As indicated by the \coq{Fail} command, the definition above is rejected by Coq.
Coq rejects the definition since it can be used to implement potentially non-terminating functions \citep[p.~6]{Dylus:2018}.
If the declaration was allowed, the type argument \coq{M} could be instantiated with the following type, for example.

\begin{minted}{coq}
  Definition NatFun (A : Type) : Type := A -> nat.
\end{minted}

When \coq{M} is instantiated with \coq{NatFun}, the second argument of the \coq{cons} constructor is a function of type \coq{list NatFun nat -> nat}.
We can now implement the following function which invokes the function inside of the list with the list itself.

\begin{minted}{coq}
  Definition applyFun (xs : List NatFun nat) : nat
    := match xs with
       | nil          => 0
       | cons mx mxs' => mxs' xs.
\end{minted}

Even though \coq{applyFun} itself is not recursive, the evaluation of an expression like \coq{applyFun (cons 0 applyFun)} does not terminate.
Since Coq requires functions to terminate on all inputs, the definition of \coq{list} with a type argument for \coq{M} is not allowed.
Therefore, \citep{Dylus:2018} model monads using a combination the free monad and a container representation for functors.
In the next two subsections, we give a brief introduction to the free monad and containers.

\subsection{Free Monad}
\label{sec:preliminaries:modeling-effects:free}
The free monad is a data type that turns any functor into a monad \cite[p.~7]{Dylus:2018}.
In Haskell the free monad can be defined as follows.
\begin{minted}{haskell}
  data Free f a = Pure a | Impure (f (Free f a))
\end{minted}
For any functor $f$, \haskell{Free @$f$@} is a monad, i.e., the following definitions fulfill the monad laws.
\begin{minted}{haskell}
  return :: Functor f => a -> Free f a
  return = Pure

  (>>=) :: Functor f => Free f a -> (a -> Free f b) -> Free f b
  (Pure x)    >>= f = f x
  (Impure fx) >>= f = fmap (>>= f) fx
\end{minted}
The free monad can be used to model, among others, the \haskell{Maybe} and \haskell{Identity} monads.
If we instantiate the functor $f$ with a data type \haskell{Zero} that does not have a constructor, we cannot create a value of type \haskell{Free Zero a} using the \haskell{Impure} constructor (in a total setting).
Therefore, only the \haskell{Pure} constructor remains and the data type behaves like \haskell{Identity}.
\begin{minted}{haskell}
  data Zero a {- polymorphic type without constructors -}
  data Identity a = Identity a
\end{minted}
Similarly, a data type \haskell{One}, with a single inhabitant, can be used to to model the \haskell{Maybe} monad.
\begin{minted}{haskell}
  data One a = One
  data Maybe a = Just a | Nothing
\end{minted}
The \haskell{Pure} constructor corresponds to \haskell{Just} and \haskell{Impure ()} corresponds to \haskell{Nothing}.

In the context of our monadic translation, the \haskell{Pure} constructor corresponds to an effect-free head normal form and values constructed with \haskell{Impure} are interpreted as the monad's effects \cite[p.~127]{Christiansen:2019}.
In case of the \haskell{Identity} monad, there are no effects and in case of the \haskell{Maybe} monad, there is exactly one effect: the absence of a value.

Unfortunately, if we try to define \coq{Free} in Coq, we run into the same problems as with \coq{list} in the previous subsection.
\begin{minted}{coq}
  Fail Inductive Free (F : Type -> Type) (A : Type) : Type
    := pure   : A -> Free F A
     | impure : F (Free F A) -> Free F A.
\end{minted}
To eliminate the possibility of defining non-terminating functions using \coq{Free}, the type argument \coq{F} is replaced by a container data structure that models the original functor but does not permit types like \coq{NatFun} which were used to implement non-terminating functions.

\subsection{Containers}
\label{sec:preliminaries:modeling-effects:containers}
Containers provide an abstraction for modeling data types that store values \cite[p.~8]{Dylus:2018}.
A list, for example, can be characterized through its length and a function that maps indices to values within the list.
Similarly, a tree can be modeled by a function that labels its leafs.
This time, the values are not identified by a single index but by a more complex \textit{position} within the tree (e.g., the path to the leaf from the root).
Just as the length of the list determines which indices are valid positions within the list, the exact \textit{shape} of the tree determines the valid positions of leafs.

In general, a container is characterized by its \textit{shape} and a function that maps \textit{positions} within the shape to values stored by the container.
We will denote the data type of the container's shape as $\Shape$.
The position data type \coq{@$\Pos$@ s} depends on the concrete choice of a shape \coq{s : @$\Shape$@}.
In case of lists, the shape is a natural number (i.e., the length of the list) and the position type is an interval of valid indices.
\begin{align*}
  \Shape &= \mathbb{N}
  \\
  \Pos(n) &= [0; n)
\end{align*}

We want to use containers to model functors that are passed into the free monad.
For modeling the \haskell{Identity} and \haskell{Maybe} monads, we introduced the functors \haskell{Zero} and \haskell{One}, respectively.
Since there are no constructors in case of the data type \haskell{Zero}, no values of type \haskell{Zero @$\tau$@} exist for any type $\tau$.
Hence, values of type \haskell{Zero @$\tau$@} neither have a shape nor any positions where values of type $\tau$ could be stored.
\begin{minted}{coq}
  Inductive Void : Type := (* non-polymorphic type without constructors *).
  Definition @$\Shape_{Zero}$@ = Void.
  Definition @$\Pos_{Zero}$@ (s : @$\Shape_{Zero}$@) = Void.
\end{minted}
The data type \haskell{One}, on the other hand, has exactly one constructor without any arguments.
Thus, all values of type \haskell{One @$\tau$@} have the same shape.
In the following listing we are using the \coq{unit} data type as defined in Coq's standard library.
Since, the constructor of \haskell{One} has no arguments, there are again no positions inside of values of type \haskell{One @$\tau$@}.
\begin{minted}{coq}
  Inductive unit : Type := tt : unit.
  Definition @$\Shape_{One}$@ = unit.
  Definition @$\Pos_{One}$@ (s : @$\Shape_{One}$@) = Void.
\end{minted}

Finally, we need a way to incorporate containers into the definition of \coq{Free}.
For this purpose, we replace the type argument \coq{F} by two new type arguments for $\Shape$ and $\Pos$ respectively.
In the \coq{impure} constructor instead of a data structure of type \coq{F (Free F A)} we need the concrete shape \coq{s} that characterizes the container and a function \coq{pf} that maps positions to values inside of the container.
In this case, the values inside of the container are free monads themselves.
\begin{minted}{coq}
  Inductive Free (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (A : Type) : Type
    := pure   : A -> Free @$\Shape$@ @$\Pos$@ A
     | impure : forall (s : @$\Shape$@) (pf : @$\Pos$@ s -> Free @\Shape@ @$\Pos$@ A), Free @\Shape@ @$\Pos$@ A
\end{minted}
This time, Coq does not reject the definition anymore.
Therefore, we will use this definition of \coq{Free} for the effect-generic monadic translation implemented by our compiler.
