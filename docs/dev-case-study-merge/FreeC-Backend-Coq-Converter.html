<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>FreeC.Backend.Coq.Converter</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/FreeC.Backend.Coq.Converter.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">free-compiler-0.2.0.0: A Haskell to Coq compiler.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">FreeC.Backend.Coq.Converter</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Modules</a></li><li><a href="#g:2">Data Type Declarations</a></li><li><a href="#g:3">Function Declarations</a></li><li><a href="#g:4">Type Expressions</a></li><li><a href="#g:5">Expressions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module exports functions for generating Coq that uses the <code>Free</code>
   monad from out intermediate representation.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:convertModule">convertModule</a> :: <a href="FreeC-IR-Syntax-Module.html#t:Module" title="FreeC.IR.Syntax.Module">Module</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertDecls">convertDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; [<a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertTypeDecls">convertTypeDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertTypeComponent">convertTypeComponent</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> ([Sentence], [Sentence])</li><li class="src short"><a href="#v:convertDataDecls">convertDataDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> ([Sentence], [Sentence])</li><li class="src short"><a href="#v:convertDataDecl">convertDataDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> (IndBody, ([Sentence], [Sentence]))</li><li class="src short"><a href="#v:convertFuncDecls">convertFuncDecls</a> :: [<a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertFuncComponent">convertFuncComponent</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertNonRecFuncDecl">convertNonRecFuncDecl</a> :: <a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Sentence</li><li class="src short"><a href="#v:convertRecFuncDecls">convertRecFuncDecls</a> :: [<a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertType">convertType</a> :: <a href="FreeC-IR-Syntax-Type.html#t:Type" title="FreeC.IR.Syntax.Type">Type</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Term</li><li class="src short"><a href="#v:convertType-39-">convertType'</a> :: <a href="FreeC-IR-Syntax-Type.html#t:Type" title="FreeC.IR.Syntax.Type">Type</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Term</li><li class="src short"><a href="#v:convertExpr">convertExpr</a> :: <a href="FreeC-IR-Syntax-Expr.html#t:Expr" title="FreeC.IR.Syntax.Expr">Expr</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Term</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Modules</h1></a><div class="top"><p class="src"><a id="v:convertModule" class="def">convertModule</a> :: <a href="FreeC-IR-Syntax-Module.html#t:Module" title="FreeC.IR.Syntax.Module">Module</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.Module.html#convertModule" class="link">Source</a> <a href="#v:convertModule" class="selflink">#</a></p><div class="doc"><p>Converts an IR module to Gallina sentences.</p></div></div><div class="top"><p class="src"><a id="v:convertDecls" class="def">convertDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; [<a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.Module.html#convertDecls" class="link">Source</a> <a href="#v:convertDecls" class="selflink">#</a></p><div class="doc"><p>Converts the given declarations of an IR module.</p></div></div><a href="#g:2" id="g:2"><h1>Data Type Declarations</h1></a><div class="top"><p class="src"><a id="v:convertTypeDecls" class="def">convertTypeDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.Module.html#convertTypeDecls" class="link">Source</a> <a href="#v:convertTypeDecls" class="selflink">#</a></p><div class="doc"><p>Converts the given data type or type synonym declarations.</p></div></div><div class="top"><p class="src"><a id="v:convertTypeComponent" class="def">convertTypeComponent</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> ([Sentence], [Sentence]) <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertTypeComponent" class="link">Source</a> <a href="#v:convertTypeComponent" class="selflink">#</a></p><div class="doc"><p>Converts a strongly connected component of the type dependency graph and
   creates a separate lit of qualified smart constructor notations.</p></div></div><div class="top"><p class="src"><a id="v:convertDataDecls" class="def">convertDataDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> ([Sentence], [Sentence]) <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertDataDecls" class="link">Source</a> <a href="#v:convertDataDecls" class="selflink">#</a></p><div class="doc"><p>Converts multiple (mutually recursive) Haskell data type declaration
   declarations.</p><p>Before the declarations are actually translated, their identifiers are
   inserted into the current environment. Otherwise the data types would
   not be able to depend on each other. The identifiers for the constructors
   are inserted into the current environment as well. This makes the
   constructors more likely to keep their original name if there is a type
   variable with the same (lowercase) name.</p><p>After the <code>Inductive</code> sentences for the data type declarations there
   is one <code>Arguments</code> sentence and several smart constructor <code>Notation</code>
   declarations for each constructor declaration of the given data types.
   Qualified smart constructor notations are packed into a separate list.</p></div></div><div class="top"><p class="src"><a id="v:convertDataDecl" class="def">convertDataDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> (IndBody, ([Sentence], [Sentence])) <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertDataDecl" class="link">Source</a> <a href="#v:convertDataDecl" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell data type declaration to the body of a Coq <code>Inductive</code>
   sentence, the <code>Arguments</code> sentences for it's constructors and the smart
   constructor notations and creates an induction scheme.
   Qualified smart constructor notations are packed into a separate list.</p><p>Type variables declared by the data type or the smart constructors are
   not visible outside of this function.</p></div></div><a href="#g:3" id="g:3"><h1>Function Declarations</h1></a><div class="top"><p class="src"><a id="v:convertFuncDecls" class="def">convertFuncDecls</a> :: [<a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.FuncDecl.html#convertFuncDecls" class="link">Source</a> <a href="#v:convertFuncDecls" class="selflink">#</a></p><div class="doc"><p>Converts the given function declarations.</p></div></div><div class="top"><p class="src"><a id="v:convertFuncComponent" class="def">convertFuncComponent</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.FuncDecl.html#convertFuncComponent" class="link">Source</a> <a href="#v:convertFuncComponent" class="selflink">#</a></p><div class="doc"><p>Converts a strongly connected component of the function dependency graph.</p></div></div><div class="top"><p class="src"><a id="v:convertNonRecFuncDecl" class="def">convertNonRecFuncDecl</a> :: <a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Sentence <a href="src/FreeC.Backend.Coq.Converter.FuncDecl.NonRec.html#convertNonRecFuncDecl" class="link">Source</a> <a href="#v:convertNonRecFuncDecl" class="selflink">#</a></p><div class="doc"><p>Converts a non-recursive Haskell function declaration to a Coq
   <code>Definition</code> sentence.</p></div></div><div class="top"><p class="src"><a id="v:convertRecFuncDecls" class="def">convertRecFuncDecls</a> :: [<a href="FreeC-IR-Syntax-FuncDecl.html#t:FuncDecl" title="FreeC.IR.Syntax.FuncDecl">FuncDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.FuncDecl.Rec.html#convertRecFuncDecls" class="link">Source</a> <a href="#v:convertRecFuncDecls" class="selflink">#</a></p><div class="doc"><p>Converts (mutually) recursive Haskell function declarations to Coq.</p><p>The function declarations are analyzed first. If they contain constant
   arguments (i.e. arguments that are passed unchanged between recursive
   calls), they are converted using a <code>Section</code> sentence (see
   <code><a href="FreeC-Backend-Coq-Converter-FuncDecl-Rec-WithHelpers.html#v:convertRecFuncDeclsWithHelpers" title="FreeC.Backend.Coq.Converter.FuncDecl.Rec.WithHelpers">convertRecFuncDeclsWithHelpers</a></code>). Otherwise they are converted into
   helper and main functions (see <code><a href="FreeC-Backend-Coq-Converter-FuncDecl-Rec-WithSections.html#v:convertRecFuncDeclsWithSection" title="FreeC.Backend.Coq.Converter.FuncDecl.Rec.WithSections">convertRecFuncDeclsWithSection</a></code>).</p></div></div><a href="#g:4" id="g:4"><h1>Type Expressions</h1></a><div class="top"><p class="src"><a id="v:convertType" class="def">convertType</a> :: <a href="FreeC-IR-Syntax-Type.html#t:Type" title="FreeC.IR.Syntax.Type">Type</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Term <a href="src/FreeC.Backend.Coq.Converter.Type.html#convertType" class="link">Source</a> <a href="#v:convertType" class="selflink">#</a></p><div class="doc"><p>Converts a type from IR to Coq, lifting it into the <code>Free</code> monad.</p><dl><dt>\(\tau^\dagger = Free\,Shape\,Pos\,\tau^*\)</dt><dd>A type \(\tau\) is converted by lifting it into the <code>Free</code> monad and
     recursively converting the argument and return types of functions
     using <code><a href="FreeC-Backend-Coq-Converter.html#v:convertType-39-" title="FreeC.Backend.Coq.Converter">convertType'</a></code>.</dd></dl></div></div><div class="top"><p class="src"><a id="v:convertType-39-" class="def">convertType'</a> :: <a href="FreeC-IR-Syntax-Type.html#t:Type" title="FreeC.IR.Syntax.Type">Type</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Term <a href="src/FreeC.Backend.Coq.Converter.Type.html#convertType%27" class="link">Source</a> <a href="#v:convertType-39-" class="selflink">#</a></p><div class="doc"><p>Converts a type from IR to Coq.</p><p>In contrast to <code><a href="FreeC-Backend-Coq-Converter.html#v:convertType" title="FreeC.Backend.Coq.Converter">convertType</a></code>, the type itself is not lifted into the
   <code>Free</code> monad. Only the argument and return types of the contained function
   type constructors are lifted recursively.</p><dl><dt>\(\alpha^* = \alpha'\)</dt><dd>A type variable \(\alpha\) is translated by looking up the corresponding
     Coq identifier \(\alpha'\).</dd><dt>\(T^* = T'\,Shape\,Pos\)</dt><dd>A type constructor \(T\) is translated by looking up the corresponding
     Coq identifier \(T'\) and adding the parameters \(Shape\) and \(Pos\).</dd><dt>\((\tau_1\,\tau_2)^* = \tau_1^*\,\tau_2^*\)</dt><dd>Type constructor applications are translated recursively but
     remain unchanged otherwise.</dd><dt>\((\tau_1 \rightarrow \tau_2)^* = \tau_1^\dagger \rightarrow \tau_2^\dagger\)</dt><dd>Type constructor applications are translated recursively but
     remain unchanged otherwise.</dd></dl></div></div><a href="#g:5" id="g:5"><h1>Expressions</h1></a><div class="top"><p class="src"><a id="v:convertExpr" class="def">convertExpr</a> :: <a href="FreeC-IR-Syntax-Expr.html#t:Expr" title="FreeC.IR.Syntax.Expr">Expr</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> Term <a href="src/FreeC.Backend.Coq.Converter.Expr.html#convertExpr" class="link">Source</a> <a href="#v:convertExpr" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell expression to Coq.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>