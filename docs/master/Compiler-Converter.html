<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Compiler.Converter</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Compiler.Converter.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">haskellToCoqCompiler-0.1.0.0: A Haskell to Coq compiler.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Compiler.Converter</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Modules</a></li><li><a href="#g:2">Data type declarations</a></li><li><a href="#g:3">Function declarations</a></li><li><a href="#g:4">Type expressions and type schemas</a></li><li><a href="#g:5">Expressions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module exports functions for converting Haskell to Coq using the
   <code>Free</code> monad.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:convertModule">convertModule</a> :: <a href="Compiler-Haskell-AST.html#t:Module" title="Compiler.Haskell.AST">Module</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertDecls">convertDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a>] -&gt; [<a href="Compiler-Haskell-AST.html#t:TypeSig" title="Compiler.Haskell.AST">TypeSig</a>] -&gt; [<a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertTypeDecls">convertTypeDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertTypeComponent">convertTypeComponent</a> :: <a href="Compiler-Analysis-DependencyAnalysis.html#t:DependencyComponent" title="Compiler.Analysis.DependencyAnalysis">DependencyComponent</a> <a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertDataDecls">convertDataDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertDataDecl">convertDataDecl</a> :: <a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> (IndBody, [Sentence])</li><li class="src short"><a href="#v:convertFuncDecls">convertFuncDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertFuncComponent">convertFuncComponent</a> :: <a href="Compiler-Analysis-DependencyAnalysis.html#t:DependencyComponent" title="Compiler.Analysis.DependencyAnalysis">DependencyComponent</a> <a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertNonRecFuncDecl">convertNonRecFuncDecl</a> :: <a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Sentence</li><li class="src short"><a href="#v:convertRecFuncDecls">convertRecFuncDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertType">convertType</a> :: <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term</li><li class="src short"><a href="#v:convertType-39-">convertType'</a> :: <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term</li><li class="src short"><a href="#v:convertTypeSchema">convertTypeSchema</a> :: <a href="Compiler-Haskell-AST.html#t:TypeSchema" title="Compiler.Haskell.AST">TypeSchema</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term</li><li class="src short"><a href="#v:convertExpr">convertExpr</a> :: <a href="Compiler-Haskell-AST.html#t:Expr" title="Compiler.Haskell.AST">Expr</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Modules</h1></a><div class="top"><p class="src"><a id="v:convertModule" class="def">convertModule</a> :: <a href="Compiler-Haskell-AST.html#t:Module" title="Compiler.Haskell.AST">Module</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.Module.html#convertModule" class="link">Source</a> <a href="#v:convertModule" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell module to a Gallina sentences.</p></div></div><div class="top"><p class="src"><a id="v:convertDecls" class="def">convertDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a>] -&gt; [<a href="Compiler-Haskell-AST.html#t:TypeSig" title="Compiler.Haskell.AST">TypeSig</a>] -&gt; [<a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.Module.html#convertDecls" class="link">Source</a> <a href="#v:convertDecls" class="selflink">#</a></p><div class="doc"><p>Converts the given declarations of a Haskell module.</p></div></div><a href="#g:2" id="g:2"><h1>Data type declarations</h1></a><div class="top"><p class="src"><a id="v:convertTypeDecls" class="def">convertTypeDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.Module.html#convertTypeDecls" class="link">Source</a> <a href="#v:convertTypeDecls" class="selflink">#</a></p><div class="doc"><p>Converts the given data type or type synonym declarations.</p></div></div><div class="top"><p class="src"><a id="v:convertTypeComponent" class="def">convertTypeComponent</a> :: <a href="Compiler-Analysis-DependencyAnalysis.html#t:DependencyComponent" title="Compiler.Analysis.DependencyAnalysis">DependencyComponent</a> <a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.TypeDecl.html#convertTypeComponent" class="link">Source</a> <a href="#v:convertTypeComponent" class="selflink">#</a></p><div class="doc"><p>Converts a strongly connected component of the type dependency graph.</p></div></div><div class="top"><p class="src"><a id="v:convertDataDecls" class="def">convertDataDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.TypeDecl.html#convertDataDecls" class="link">Source</a> <a href="#v:convertDataDecls" class="selflink">#</a></p><div class="doc"><p>Converts multiple (mutually recursive) Haskell data type declaration
   declarations.</p><p>Before the declarations are actually translated, their identifiers are
   inserted into the current environement. Otherwise the data types would
   not be able to depend on each other. The identifiers for the constructors
   are inserted into the current environmen as well. This makes the
   constructors more likely to keep their original name if there is a type
   variable with the same (lowercase) name.</p><p>After the <code>Inductive</code> sentences for the data type declarations there
   is one <code>Arguments</code> sentence and one smart constructor declaration for
   each constructor declaration of the given data types.</p></div></div><div class="top"><p class="src"><a id="v:convertDataDecl" class="def">convertDataDecl</a> :: <a href="Compiler-Haskell-AST.html#t:TypeDecl" title="Compiler.Haskell.AST">TypeDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> (IndBody, [Sentence]) <a href="src/Compiler.Converter.TypeDecl.html#convertDataDecl" class="link">Source</a> <a href="#v:convertDataDecl" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell data type declaration to the body of a Coq <code>Inductive</code>
   sentence, the <code>Arguments</code> sentences for it's constructors and the smart
   constructor declarations.</p><p>This function assumes, that the identifiers for the declared data type
   and it's (smart) constructors are defined already (see <code><a href="Compiler-Converter-TypeDecl.html#v:defineTypeDecl" title="Compiler.Converter.TypeDecl">defineTypeDecl</a></code>).
   Type variables declared by the data type or the smart constructors are
   not visible outside of this function.</p></div></div><a href="#g:3" id="g:3"><h1>Function declarations</h1></a><div class="top"><p class="src"><a id="v:convertFuncDecls" class="def">convertFuncDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.Module.html#convertFuncDecls" class="link">Source</a> <a href="#v:convertFuncDecls" class="selflink">#</a></p><div class="doc"><p>Converts the given function declarations.</p></div></div><div class="top"><p class="src"><a id="v:convertFuncComponent" class="def">convertFuncComponent</a> :: <a href="Compiler-Analysis-DependencyAnalysis.html#t:DependencyComponent" title="Compiler.Analysis.DependencyAnalysis">DependencyComponent</a> <a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.FuncDecl.html#convertFuncComponent" class="link">Source</a> <a href="#v:convertFuncComponent" class="selflink">#</a></p><div class="doc"><p>Converts a strongly connected component of the function dependency graph.</p></div></div><div class="top"><p class="src"><a id="v:convertNonRecFuncDecl" class="def">convertNonRecFuncDecl</a> :: <a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Sentence <a href="src/Compiler.Converter.FuncDecl.NonRec.html#convertNonRecFuncDecl" class="link">Source</a> <a href="#v:convertNonRecFuncDecl" class="selflink">#</a></p><div class="doc"><p>Converts a non-recursive Haskell function declaration to a Coq
   <code>Definition</code> sentence.</p></div></div><div class="top"><p class="src"><a id="v:convertRecFuncDecls" class="def">convertRecFuncDecls</a> :: [<a href="Compiler-Haskell-AST.html#t:FuncDecl" title="Compiler.Haskell.AST">FuncDecl</a>] -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> [Sentence] <a href="src/Compiler.Converter.FuncDecl.Rec.html#convertRecFuncDecls" class="link">Source</a> <a href="#v:convertRecFuncDecls" class="selflink">#</a></p><div class="doc"><p>Converts (mutually) recursive Haskell function declarations to Coq.</p><p>The function declarations are analysed first. If they contain constant
   arguments (i.e. arguments that are passed unchanged betwen recursive
   calls), they are converted using a <code>Section</code> sentence. Otherwise they
   are converted into helper and main functions.</p></div></div><a href="#g:4" id="g:4"><h1>Type expressions and type schemas</h1></a><div class="top"><p class="src"><a id="v:convertType" class="def">convertType</a> :: <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term <a href="src/Compiler.Converter.Type.html#convertType" class="link">Source</a> <a href="#v:convertType" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell type to Coq, lifting it into the <code>Free</code> monad.</p><dl><dt>\(\tau^\dagger = Free\,Shape\,Pos\,\tau^*\)</dt><dd>A type \(\tau\) is converted by lifting it into the <code>Free</code> monad and
     recursivly converting the argument and return types of functions
     using <code><a href="Compiler-Converter.html#v:convertType-39-" title="Compiler.Converter">convertType'</a></code>.</dd></dl></div></div><div class="top"><p class="src"><a id="v:convertType-39-" class="def">convertType'</a> :: <a href="Compiler-Haskell-AST.html#t:Type" title="Compiler.Haskell.AST">Type</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term <a href="src/Compiler.Converter.Type.html#convertType%27" class="link">Source</a> <a href="#v:convertType-39-" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell type to Coq.</p><p>In contrast to <code><a href="Compiler-Converter.html#v:convertType" title="Compiler.Converter">convertType</a></code>, the type itself is not lifted into the
   <code>Free</code> moand. Only the argument and return types of contained function
   type constructors are lifted recursivly.</p><dl><dt>\(\alpha^* = \alpha'\)</dt><dd>A type variable \(\alpha\) is translated by looking up the corresponding
     Coq identifier \(\alpha'\).</dd><dt>\(T^* = T'\,Shape\,Pos\)</dt><dd>A type constructor \(T\) is translated by looking up the corresponding
     Coq identifier \(T'\) and adding the parameters \(Shape\) and \(Pos\).</dd><dt>\((\tau_1\,\tau_2)^* = \tau_1^*\,\tau_2^*\)</dt><dd>Type constructor applications are translated recursively but
     remain unchanged otherwise.</dd><dt>\((\tau_1 \rightarrow \tau_2)^* = \tau_1^\dagger \rightarrow \tau_2^\dagger\)</dt><dd>Type constructor applications are translated recursively but
     remain unchanged otherwise.</dd></dl></div></div><div class="top"><p class="src"><a id="v:convertTypeSchema" class="def">convertTypeSchema</a> :: <a href="Compiler-Haskell-AST.html#t:TypeSchema" title="Compiler.Haskell.AST">TypeSchema</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term <a href="src/Compiler.Converter.TypeSchema.html#convertTypeSchema" class="link">Source</a> <a href="#v:convertTypeSchema" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell type schema to Coq.</p></div></div><a href="#g:5" id="g:5"><h1>Expressions</h1></a><div class="top"><p class="src"><a id="v:convertExpr" class="def">convertExpr</a> :: <a href="Compiler-Haskell-AST.html#t:Expr" title="Compiler.Haskell.AST">Expr</a> -&gt; <a href="Compiler-Monad-Converter.html#t:Converter" title="Compiler.Monad.Converter">Converter</a> Term <a href="src/Compiler.Converter.Expr.html#convertExpr" class="link">Source</a> <a href="#v:convertExpr" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell expression to Coq.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>