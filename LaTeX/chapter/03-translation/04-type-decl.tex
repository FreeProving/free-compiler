\section{Translation of Type Declarations} \label{sec:translation:type-decl}
This section covers the translation of type synonyms and data type declarations.

Because the order of declarations matters in Coq, special care needs to be taken to translate only declarations whose dependencies were translated before.
We say that a type expression $\tau$ depends on the declaration of a type constructor $T$ (e.g. the name of a type synonym or data type declaration) if $\tau$ contains an application of the type constructor $T$.
For short we also say that $\tau$ depends on or uses $T$.
A type synonym now depends on all type constructor used by its right hand side.
Likewise, a data type declaration depends on all type constructors used by the fields of its data constructors.

For simplicity we will first consider only individual declarations and assume all additional data types used by our examples to have been declared beforehand.
At the end of this section, we describe how to translate multiple type declarations without introducing dependency related issues to the generated Coq code.
We also extend the translation rules to support mutually recursive declarations in the final subsection.

\subsection{Translation of Type Synonym Declarations}
Type synonyms can be used in Haskell to give a name to a more complex type expression.
Similarly we can use a \coq{Definition}-sentence to to assign a name to a term in Coq.
Because Coq does not distinguish types and terms, declarations of type synonyms can be simply translated to \coq{Definition}-sentences as shown in \autoref{fig:translation:type-decl:type-syn}.

\begin{figure}[H]
  \begin{align*}
    \toCoq{(
      \haskellM{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@}
     )}
    = \coqM{Definition @$S'$@} &\;\coqM{(@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)           } \\
                               &\;\coqM{(@$\alpha_1'$@ @$\ldots$@ @$\alpha_n'$@ : Type)} \\
                               &\;\coqM{: Type                                         } \\
                               &\;\coqM{:= @${\tau}^{*}$@.                             } % FIXME \toCoqT does not work in this situation.
  \end{align*}
  \caption{Translation rule for $n$-ary polymorphic type synonym declarations.}
  \label{fig:translation:type-decl:type-syn}
\end{figure}

The parameters $\Shape$ and $\Pos$ have to be added such that the translated type can use the free monad or other data types.
For example the following type synonym
\begin{minted}{haskell}
  type Queue a = [a]
\end{minted}
needs $\Shape$ and $\Pos$ when translated to to Coq because they need to be passed to \coq{List}.
\begin{minted}{coq}
  Definition Queue (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
                   := List @$\Shape$@ @$\Pos$@ a.
\end{minted}

On the right hand side of the \coq{Definition}-sentence in \autoref{fig:translation:type-decl:type-syn} the $\toCoqT{}$ translation is applied instead of $\toCoq{}$.
This is because we desire the expansion of type synonyms in Haskell and Coq to be compatible with respect to the $\toCoq{}$ translation.
To convince ourselves that the translation rule above fulfills this property lets denote the expansion of type synonyms in Haskell and Coq with $\beta_H$ and $\beta_C$ respectively and show that for all type synonyms \haskell{type @$S$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ = @$\tau$@} and type expressions $\tau_1, \ldots \tau_n$ the following holds true.
\[
  \toCoq{\beta_H(S\;\tau_1\;\ldots\;\tau_n)}
  = \beta_C(\toCoq{(S\;\tau_1\;\ldots\;\tau_n)})
\]

For the instantiation of $S$ and $S'$ we first define substitutions $\sigma$ and $\sigma'$.
\begin{align*}
  \sigma &\coloneqq \{\, \alpha_1 \mapsto \tau_1, \ldots, \alpha_n \mapsto \tau_n \,\} \\
  \sigma' &\coloneqq \{\, \alpha_1' \mapsto \toCoqT{\tau_1}, \ldots, \alpha_n' \mapsto \toCoqT{\tau_n} \,\}
\end{align*}
Now we can proof the proposition by applying the translation rules for types presented in the previous section.

\begin{align*}
  \toCoq{\beta_H(S\;\tau_1\;\ldots\;\tau_n)}
    &= \toCoq{\sigma(\tau)}
       \tag{expansion of $S$} \\
    &= \Free{\toCoqT{\sigma(\tau)}}
       \tag{\autoref{eqn:translation:type}} \\
    &= \Free{\sigma'(\toCoqT{\tau})}
       \tag{$\star$} \\
    &= \beta_C{(\Free{(\genApply{S'}\;\toCoqT{\tau_1}\;\ldots\;\toCoqT{\tau_n})})}
       \tag{undo expansion of $S'$} \\
    &= \beta_C{(\Free{\toCoqT{(S\;\tau_1\;\ldots\;\tau_n)}})}
       \tag{\autoref{eqn:translation:type:application} and \ref{eqn:translation:type:constructor}} \\
    &= \beta_C(\toCoq{(S\;\tau_1\;\ldots\;\tau_n)})
       \tag{\autoref{eqn:translation:type}}
\end{align*}
\qed

The equation marked with $(\star)$ follows from the following property of $\sigma$ and $\sigma'$.
\begin{align*}
  \toCoqT{\sigma(\alpha_i)} = \toCoqT{\tau_i}
                            = \sigma'(\alpha_i')
                            = \sigma'(\toCoqT{\alpha_i})
  &&\forall i \in \{\, 1, \ldots, n \,\}
\end{align*}
We assume without a proof that this property holds for the extensions of $\sigma$ and $\sigma'$ as well.

\subsection{Translation of Data Type Declarations}
Until now we have described how to translate type expressions and assign names to them but we are not able to actually define our own types for usage in those type expressions.
One of the simplest kinds of data types that can be defined in Haskell are so called \textit{sum types}.
A well known expamle for a sum type is \haskell{Bool} which is commonly defined as follows.
\begin{minted}{haskell}
  data Bool = True | False
\end{minted}
In general, the constructors of a sum type do not have any arguments and are enumerated on the right hand side of a \haskell{data} type declaration.
In Coq data types are defined using \coq{Inductive}-sentences in a very similar fation to \haskell{data} declarations in Haskell.
The \haskell{Bool} type could look like this for example.
\begin{minted}{coq}
  Inductive Bool : Type
    := true  : Bool
     | false : Bool.
\end{minted}
Apart from the concrete syntax, the main difference is that the type of the constructors is annotated explicitly.
In contrast to Haskell, we follow the Coq convention to choose lower case names for the constructors.

Sum types on their own are usually not very usefull.
Instead one wishes to compose existing data types to more interesting data structures.
Such types are refered to as \textit{product types}.
If there was for instance a type \haskell{Double} that represents floating point numbers, we could compose two such numbers to model a complex number.
\begin{minted}{haskell}
  data Complex = Complex Double Double
\end{minted}
This time the constructor \haskell{Complex} is not a constant like \haskell{True} but a function that takes two values of type \haskell{Double} and produces a \haskell{Complex} number.
\begin{minted}{haskell}
  GHCi> :t Complex
  Complex :: Double -> Double -> Complex
\end{minted}
This insight is important, as we need to annotate the full type of the constructor in Coq again.
By applying the translation rules for types we would obtain the following Coq type for the constructor.
\begin{align*}
  \toCoqT{(Double \rightarrow Double \rightarrow Complex)}
    &= \toCoq{Double} \rightarrow \toCoq{(Double \rightarrow Complex)}
    \tag{\autoref{eqn:translation:type:function}}
    \\
    &= \toCoq{Double} \rightarrow \Free{\toCoqT{(Double \rightarrow Complex)}}
    \tag{\autoref{eqn:translation:type}}
\end{align*}
Wrapping the return type of a constructor is not allowed in Coq though.
However, it is not necessary for us to lift the intermediate results of the constructor either.
This is because (partial) constructor applications never have an effect in Haskell.
Therefore, it is sufficent to lift the argument types of the constructor (which could indeed be effectful).
For this purpose we still need to add the parameters $\Shape$ and $\Pos$ to the generated sentence.
\begin{minted}{coq}
  Inductive Complex (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) : Type
    := complex : Free @$\Shape$@ @$\Pos$@ (Double @$\Shape$@ @$\Pos$@)
              -> Free @$\Shape$@ @$\Pos$@ (Double @$\Shape$@ @$\Pos$@)
              -> Complex @$\Shape$@ @$\Pos$@.
\end{minted}

Haskell allows us to use \textit{parametric polymorphism} to generalize from this example and define pairs of two arbitrary types.
\begin{minted}{haskell}
  data Pair a b = Pair a b
\end{minted}
Analogously to how we added the parameters $\Shape$ and $\Pos$ above, we can also introduce the type variables $a$ and $b$ in the header of the \coq{Inductive}-sentence.
\begin{minted}{coq}
  Inductive Pair (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a b : Type) : Type
    := pair : Free @$\Shape$@ @$\Pos$@ a
              -> Free @$\Shape$@ @$\Pos$@ b
              -> Pair @$\Shape$@ @$\Pos$@ a b.
\end{minted}
We wrap the binders of $a$ and $b$ in regular parentheses, because we want to pass the type arguments explicitly to \coq{Pair} when we instantiate the data type.
However, Coq also adds all parameters of the \coq{Inductive}-sentence to the constructors automatically, i.e. \coq{pair} takes four additional parameters.
\begin{minted}{coq}
  Check pair.
  (* ==> pair : forall (Shape : Type) (Pos : Shape -> Type) (a b : Type),
                Free Shape Pos a -> Free Shape Pos b -> Pair Shape Pos a b *)
\end{minted}
For convenience we can "hide" those arguments using an \coq{Arguments}-sentence.
\begin{minted}{coq}
  Arguments pair {@$\Shape$@} {@$\Pos$@} {a} {b}.
\end{minted}
Coq will then try to infer the values of $\Shape$, $\Pos$, $a$ and $b$ from the context as well as the types of the remaining arguments.
\begin{minted}{coq}
  Check pair.
  (* ==> pair : Free ?Shape ?Pos ?a -> Free ?Shape ?Pos ?b -> Pair ?Shape ?Pos ?a ?b
            where
              ?Shape : [ |- Type]
              ?Pos : [ |- ?Shape -> Type]
              ?a : [ |- Type]
              ?b : [ |- Type] *)
\end{minted}

Both Haskell and Coq do not require us to distinguish sum and product types.
For example, we can combine both concepts to define a data type for optional values.
\begin{minted}{haskell}
  data Maybe a = Nothing | Just a
\end{minted}
As shown in \autoref{fig:translation:type-decl:data}, an arbitrary data type can be translated similar to how we translated product types above.
Just as with sum types, additional constructors are separated by a vertical bar.

\begin{figure}[H]
  \[
    \toCoq{\left(
      \begin{array}{ll}
        \haskellM{data @$D$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@}              \\
          \quad\haskellM{= @$C_1$@ @$\tau_{1,1}$@ @$\ldots$@  @$\tau_{1,p_1}$@} \\
          \quad\haskellM{| @$\ldots$@}                                          \\
          \quad\haskellM{| @$C_m$@ @$\tau_{m,1}$@ @$\ldots$@  @$\tau_{m,p_m}$@}
      \end{array}
    \right)}
    = \begin{array}{l}
      \coqM{Inductive @$D$@ (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type)}                      \\
      \phantom{\coqM{Inductive @$D$@}}\;\;\coqM{(@$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ : Type) : Type} \\
      \quad\coqM{:= @$c_1'$@ : @${\tau_{1,1}}^{\dagger}$@ -> @$\ldots$@ -> @${\tau_{1,p_1}}^{\dagger}$@ -> @${(D\;\alpha_1\;\ldots\;\alpha_n)}^{*}$@} \\
      \quad\;\;\coqM{| @$\ldots$@}                                                                                                                             \\
      \quad\;\;\coqM{| @$c_m'$@ : @${\tau_{m,1}}^{\dagger}$@ -> @$\ldots$@ -> @${\tau_{m,p_m}}^{\dagger}$@ -> @${(D\;\alpha_1\;\ldots\;\alpha_n)}^{*}$@.}
    \end{array}
  \]
  \caption{Translation rule for $n$-ary polymorphic data type declarations with $m$ constructors. In Coq we are using renamed lower case variations $c_i'$ of the Haskell constructors $C_i$.}
  \label{fig:translation:type-decl:data}
\end{figure}

If we apply this translation rule to our \haskell{Maybe} data type, we obtain the following \coq{Inductive}-sentence for example.
\begin{minted}{coq}
  Inductive Maybe (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) (a : Type) : Type
    := nothing : Maybe @$\Shape$@ @$\Pos$@ a
     | just : Free @$\Shape$@ @$\Pos$@ a
              -> Maybe @$\Shape$@ @$\Pos$@ a.
\end{minted}

Before we conclude this section, notice that we are using the $\toCoqT{}$ translation for the return type of constructors in \autoref{fig:translation:type-decl:data}.
This is because $\toCoq{}$ would lift the type to the free monad but Coq does not allow us to wrap the return type of constructors as we pointed out above already.
However, we are usually interested in lifted values.
With that end in view, we define a function for each regular constructor that simply applies the constructor and lifts it's result using the \coq{pure} constructor of the free monad.
We are going to refer to these functions as \textit{smart constructors} hereinafter.
The smart constructor for \coq{just} would look as follows.
\begin{minted}{coq}
  Definition Just (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) {a : Type}
                  (x : Free @$\Shape$@ @$\Pos$@ a)
                  : Free @$\Shape$@ @$\Pos$@ (Maybe @$\Shape$@ @$\Pos$@ a)
                  := pure (just x)
\end{minted}
This time we are using upper case indentifiers again.
Unlike with regular constructor, we do not have to generate an \coq{Arguments}-sentence for the smart constructor.
This is because we can mark the type argument as implicit directly in the \coq{Definition}-sentence by wrapping its binder in curly braces.
The general generation scheme for smart constructors and \coq{Arguments}-sentences is summarized in \autoref{fig:translation:type-decl:con}.
In case of \coq{cons} we were able to manully choose appropriate names for the arguments of the smart constructor.
However, when we generate those sentences, we need to generate \textit{fresh identifiers} automatically.
The gneration of freh identifiers will be covered in \autoref{chp:implementation}. % TODO more specific reference.

\begin{figure}[H]
  \begin{minted}{coq}
    Arguments @$c'$@ {@$\Shape$@} {@$\Pos$@} {@$\alpha_1$@} @$\ldots$@ {@$\alpha_n$@}.

    Definition @$C'$@ (@$\Shape$@ : Type) (@$\Pos$@ : @$\Shape$@ -> Type) {@$\alpha_1$@ @$\ldots$@ @$\alpha_n$@ : Type}
                  (@$x_1$@ : @$\toCoq{\tau_1}$@) @$\ldots$@ (@$x_p$@ @$\toCoq{\tau_p}$@)
                  : @$\toCoq{(D\;\alpha_1\;\ldots\;\alpha_n)}$@
                  := pure (@$C$@ @$x_1$@ @$\ldots$@ @$x_p$@)
  \end{minted}
  \caption{Additional sentences to generate for each data constructor \haskell{@$C$@ @$\tau_1$@ @$\ldots$@ @$\tau_p$@} of a data type \haskell{@$D$@ @$\alpha_1$@ @$\ldots$@ @$\alpha_n$@}. $c'$ refers to the renamed lower case constructor name. $x_1, \ldots, x_p$ are fresh identifiers.}
  \label{fig:translation:type-decl:con}
\end{figure}

\subsection{Handling Mutually Recursive Type Declarations}

% Recursive data types.
\begin{minted}{haskell}
  data List a = Nil | Cons a (List a)
\end{minted}

% Mutually recursive data types.
\begin{minted}{haskell}
  data Tree a = Tree a (Forest a)
  data Forest a = Empty | NonEmpty (Tree a) (Forest a)
\end{minted}

% Type synonyms in recursive data types.
\begin{minted}{haskell}
  data Tree a = Tree a (Forest a)
  type Forest a = List (Type a)
\end{minted}
