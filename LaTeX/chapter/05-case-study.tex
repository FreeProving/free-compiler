\chapter{Case Study} \label{chp:case-study}
In this chapter we want to evaluate whether the Coq code generated by our compiler is actually useful to prove properties about the original Haskell program.
For our evaluation, we are using an example that has been used in the articles by \cite{Abel:2005} and \cite{Dylus:2018} before.
The goal is to prove the correctness of an optimized queue implementation based on two lists by relating it to a more straightforward implementation of a queue with a single list.

\begin{figure}[H]
  \begin{tabular}{p{0.40\linewidth} | p{0.40\linewidth}}
    \begin{minted}{haskell}
      type Queue a = [a]

      empty :: Queue a
      empty = []

      isEmpty :: Queue a -> Bool
      isEmpty q = null q

      front :: Queue a -> a
      front (x:q) = x

      add :: a -> Queue a -> Queue a
      add x q = q ++ [x]
    \end{minted}
    &
    \begin{minted}{haskell}
      type QueueI a = ([a], [a])

      emptyI :: QueueI a
      emptyI = ([], [])

      isEmptyI :: QueueI a -> Bool
      isEmptyI (f, b) = null f

      frontI :: QueueI a -> a
      frontI (x : f, b) = x

      addI :: a -> QueueI a -> QueueI a
      addI x (f, b) = flipQ (f, x : b)

      flipQ :: QueueI a -> QueueI a
      flipQ ([], b) = (reverse b, [])
      flipQ q       = q
    \end{minted}
  \end{tabular}
  \caption{
    The two queue implementations.
    The implementation on the left uses a single list and the implementation on the right uses two lists.
  }
  \label{fig:case-study:original-queues}
\end{figure}

The two implementations as shown in \autoref{fig:case-study:original-queues} cannot be feed directly into our compiler since they do not comply with our assumptions (see \autoref{sec:preliminaries:assumptions}).
First, pattern matching on the left-hand side of the function declarations needs to be converted to explicit pattern matching using \haskell{case} expressions as shown in \autoref{fig:case-study:desugared-queues}.
Furthermore, we have to provide implementations for \haskell{null}, \haskell{(++)} and \haskell{reverse} as they are not yet part of the \haskell{Prelude} provided by our compiler.
Since we do not permit the declaration of custom operators, we have to rename \haskell{(++)} to \haskell{append}.
\autoref{fig:case-study:aux} shows the declarations of these auxiliary functions.
The definitions in \autoref{fig:case-study:desugared-queues} and \autoref{fig:case-study:aux} can now be converted to Coq and are also accepted by Coq.

\begin{figure}[H]
  \begin{tabular}{p{0.40\linewidth} | p{0.40\linewidth}}
    \begin{minted}{haskell}
      type Queue a = [a]

      empty :: Queue a
      empty = []

      isEmpty :: Queue a -> Bool
      isEmpty q = null q

      front :: Queue a -> a
      front q = case q of
        x : q' -> x
        []     -> undefined

      add :: a -> Queue a -> Queue a
      add x q = q `append` [x]
    \end{minted}
    &
    \begin{minted}{haskell}
      type QueueI a = ([a], [a])

      emptyI :: QueueI a
      emptyI = ([], [])

      isEmptyI :: QueueI a -> Bool
      isEmptyI q = case q of
        (f, b) -> null f

      frontI :: QueueI a -> a
      frontI q = case q of
        (f, b) -> case f of
          x : f' -> x
          []     -> undefined

      addI :: a -> QueueI a -> QueueI a
      addI x a0 = case a0 of
        (f, b) -> flipQ (f, x : b)

      flipQ :: QueueI a -> QueueI a
      flipQ q = case q of
        (f, b) -> case f of
          []     -> (reverse b, [])
          x : f' -> (x : f', b)
    \end{minted}
  \end{tabular}
  \caption{
    The two queue implementations after transforming pattern matching.
  }
  \label{fig:case-study:desugared-queues}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.40\linewidth}
    \begin{minted}{haskell}
      null :: [a] -> Bool
      null xs = case xs of
        []     -> True
        x : xs -> False

      append :: [a] -> [a] -> [a]
      append xs ys = case xs of
        []      -> ys
        x : xs' -> x : (append xs' ys)

      reverse :: [a] -> [a]
      reverse xs = case xs of
        []      -> []
        x : xs' -> reverse xs' `append` [x]
    \end{minted}
  \end{minipage}
  \caption{
    Functions required by the queue example but that are not yet defined in our \haskell{Prelude}.
  }
  \label{fig:case-study:aux}
\end{figure}

% Proving the invariant
The first property that we want to prove is that all queues constructible using the functions from the implementation with two lists fulfil the following invariant.
Again, we need to define the auxiliary function \haskell{not} that is usually part of the \haskell{Prelude}.
\begin{minted}{haskell}
  not :: Bool -> Bool
  not b = case b of
    True  -> False
    False -> True

  invariant :: QueueI a -> Bool
  invariant qi = case qi of (f,b) -> null b || not (null f)
\end{minted}
Next, we define two QuickCheck properties: one tests whether the empty queue fulfills the invariant and the other one tests whether a queue constructed by adding an arbitrary element to a queue which fulfills the invariant, preserves the invariant.
\begin{minted}{haskell}
  prop_inv_empty :: Bool
  prop_inv_empty = invariant emptyI

  prop_inv_add :: a -> QueueI a -> Property
  prop_inv_add x q = invariant q ==> invariant (addI x q)
\end{minted}
If we add a QuickCheck import to the module, our compiler generates the following \coq{Theorem} sentences.
\begin{minted}{coq}
  Theorem prop_inv_empty : forall (Shape : Type) (Pos : Shape -> Type),
    invariant Shape Pos (emptyI Shape Pos) = True_ Shape Pos.
  Proof. (* FILL IN HERE *) Admitted.

  Theorem prop_inv_add :
    forall (Shape : Type) (Pos : Shape -> Type) {a : Type}
           (x : Free Shape Pos a) (q : Free Shape Pos (QueueI Shape Pos a)),
    (invariant Shape Pos q = True_ Shape Pos) ->
    (invariant Shape Pos (addI Shape Pos x q) = True_ Shape Pos).
  Proof. (* FILL IN HERE *) Admitted.
\end{minted}
While the definition of \coq{prop_inv_add} is fine, Coq rejects the definition of \coq{prop_inv_empty} with the following error message.
\begin{minted}{text}
  Cannot infer the implicit parameter a of invariant whose type is "Type" in environment:
  Shape : Type
  Pos : Shape -> Type
\end{minted}
The problem occurs because both the \coq{invariant} and \coq{emptyI} are polymorphic.
In case of \coq{prop_inv_add}, Coq can infer the type arguments of \coq{invariant} and \coq{add} from the types of \coq{x} and \coq{q}.
However, in case of \coq{prop_inv_empty} the context contains no type information.
In fact, we wanted to prove that the empty queue fulfills the invariant for any value type, but we never quantify the value type in the theorem above.
We can fix this issue by adding a binder for a new type variable and passing this type variable explicitly to either \coq{invariant} or \coq{emptyI}.
The \texttt{@} sign before \coq{emptyI} tells Coq that we want to pass implicit arguments explicitly.
\begin{minted}[escapeinside={}]{coq}
  Theorem prop_inv_empty : forall (Shape : Type) (Pos : Shape -> Type) (a : Type),
    invariant Shape Pos (@emptyI Shape Pos a) = True_ Shape Pos.
\end{minted}
Unfortunately, it is not possible to make these changes automatically without performing type inference.
Similar problems can occur outside of QuickCheck properties as well.
For example, the following definition of \haskell{zero} would be rejected by Coq if we applied our current translation.
\begin{minted}{haskell}
  length :: [a] -> Integer
  length xs = case xs of
    []      -> 0
    x : xs' -> 1 + length xs'

  zero :: Integer
  zero = length []
\end{minted}
Apart from the small change shown above, the prove of \coq{prop_inv_empty} is straightforward since the left-hand side directly evaluates to \coq{True_ Shape Pos}.
The complete code for this chapter~--~including the proof scripts~--~can be found in the example folder of our compiler\footnote{\url{https://git.informatik.uni-kiel.de/stu203400/bachelor-thesis/tree/master/haskellToCoqCompiler/example}}.

When we attempt the prove of \coq{prop_inv_add}, we find that the property is not true if we consider partial values.
If the first component of the input queue is \haskell{undefined} and the second empty, the invariant holds for the input due to the lazy evaluation of \haskell{(||)}.
\begin{align*}
  \haskellM{invariant (undefined, [])}
  &= \haskellM{null [] || not (null undefined)} \\
  &= \haskellM{True || not (null undefined)} \\
  &= \haskellM{True}
\end{align*}
Even though the premise holds, the conclusion of the theorem is false in this example.
Since \haskell{addI} calls \haskell{flipQ} and \haskell{flipQ} performs pattern matching on the first component, the result of \haskell{addI} is \haskell{undefined} and not \haskell{True}.
\begin{align*}
  \haskellM{invariant (addI x (undefined, []))}
  &= \haskellM{invariant (flipQ (undefined, [x]))} \\
  &= \haskellM{invariant undefined} \\
  &= \haskellM{undefined}
\end{align*}
The problem is the hidden assumption of the QuickCheck property that the values passed to it are total.
\citet[p.~20]{Dylus:2018} encountered the same problem and proposed to extend the generated QuickCheck property by the premise that the given queue does not contain partial values.
For this purpose, we have to manually define inductive properties for the data types in our program that check whether all values are \coq{pure}.
Their definition follows the same pattern as the data type declaration in Coq itself and could be automated in the future.
After adding the premise, the theorem looks as follows.
\begin{minted}{coq}
  Theorem prop_inv_add :
    forall (Shape : Type) (Pos : Shape -> Type)
           {a : Type} (total_a : Free Shape Pos a -> Prop)
           (x : Free Shape Pos a) (q : Free Shape Pos (QueueI Shape Pos a)),
    total_queue Shape Pos total_a q ->
    (invariant Shape Pos q = True_ Shape Pos) ->
    (invariant Shape Pos (addI Shape Pos x q) = True_ Shape Pos).
\end{minted}
The parameter \coq{total_a} is an arbitrary notion of totality for elements of type \coq{a}.
\coq{total_queue} is one of our inductive propositions and ensures that:
\begin{itemize}
  \item the queue itself is \coq{pure},
  \item the two lists of the queue are \coq{pure},
  \item all of their sublists are \coq{pure} and
  \item the values of the queue are total with respect to \coq{total_a}.
\end{itemize}
Since \coq{total_a} is universally quantified, the extended theorem does not require the elements of the queue themselves to be total.
The inductive propositions add a lot of overhead to our Coq file but the proof of \coq{prop_inv_add} is still simple.

% Relating both implementations.
Now that we have shown that the implementation of queues with two lists satisfies the invariant, we want to prove that the implementation is compatible with the single list version.
To relate both implementations, we define a function that converts queues from one representation to the other.
\begin{minted}{haskell}
  toQueue :: QueueI a -> Queue a
  toQueue qi = case qi of
    (f, b) -> f `append` reverse b
\end{minted}
We proceed by defining the following QuickCheck properties.
In contrast to \cite{Dylus:2018}, we have to use the \haskell{(===)} operator since \haskell{(==)} only works with integers in our implementation.
The \haskell{(===)} operator is translated to Coq's structural equality by our compiler.
\begin{minted}{haskell}
  prop_isEmpty :: QueueI a -> Property
  prop_isEmpty qi = invariant qi ==> isEmptyI qi === isEmpty (toQueue qi)

  prop_add :: a -> QueueI a -> Property
  prop_add x qi = toQueue (addI x qi) === add x (toQueue qi)

  prop_front :: QueueI a -> Property
  prop_front qi = invariant qi && not (isEmptyI qi) ==> frontI qi === front (toQueue qi)
\end{minted}
Due to minor differences in the definition of the \coq{Free} monad, slight modifications need to be done to the proofs presented by \cite{Dylus:2018}.
There are further differences in the exact definition of the inductive propositions like \coq{total_queue} which we need for \coq{prop_front} again.
Apart from that we can copy their proofs.
Since their proof for \coq{prop_add} makes use of induction, we also have to copy and adapt the their induction principles for the free monad \cite[pp.~29-31]{Dylus:2018}.
As proofs by induction are very common, the induction principles have been added to our base library.
Only the theorem for \coq{prop_front} requires a \coq{Partial} instance.
The other properties are completely effect-generic.
While \cite{Dylus:2018} were only able to prove \coq{prop_front} for specific monads that model partiality, our approach with the \coq{Partial} type class allows us to extend the proof of \coq{prop_front} to all monads for which a notion of partiality exists.
