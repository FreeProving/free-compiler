\section{Assumptions} \label{sec:translation:assumtions}
\subsection{Predefined operations and data types}
Haskell's \textit{Prelude} offers a rich set of predefined data types and operations.
We do not aim to recreate the entire Prelude but still want to expose some commonly used functionalities.
We are especially interested in data types with a special syntax.
This is because we see the fact that they have their own notation as a strong indicator for their importance in actual Haskell code.
Namely, we support lists, pairs and the unit type as well as their constructors.
\autoref{tbl:translation:assumtions:predefined} lists all predefined data types and the corresponding constructors.
Internally, we will not handle these types any different from user-defined types and constructors, i.e., the following identities hold.
\begin{align*}
  \haskellM{[@$\tau$@]}
  &= \haskellM{[] @$\tau$@}
  &&\forall \tau \text{ type expression}
  \\
  \haskellM{(@$\tau_1$@, @$\tau_2$@)}
  &= \haskellM{(,) @$\tau_1$@ @$\tau_2$@}
  &&\forall \tau_1, \tau_2 \text{ type expression}
\end{align*}

In addition to the constructors, there is a more concise notation for lists and pairs.
\begin{align}
  \haskellM{[@$e_1$@, @$e_2$@, @$\ldots$@, @$e_n$@]}
  &= \haskellM{@$e_1$@ : (@$e_2$@ : (@$\ldots$@ : (@$e_n$@ : [])@$\ldots$@))}
  &&\forall e_1, e_2, \ldots, e_n \text{ expression}
  \label{eqn:translation:assumtions:list-literal}
  \\
  \haskellM{(@$e_1$@, @$e_2$@)}
  &= \haskellM{(,) @$e_1$@ @$e_2$@}
  &&\forall e_1, e_2 \text{ expression}
  \label{eqn:translation:assumtions:pair-literal}
\end{align}

Furthermore, \autoref{tbl:translation:assumtions:predefined} lists \haskell{Bool} and \haskell{Integer} as predefined data types.
In theory \haskell{Bool} and its constructors \haskell{True} and \haskell{False} could be defined by the user.
However, \haskell{Bool} is important for the translation of \haskell{if} expressions.
Due to the lack of type classes, \haskell{Integer} will be used as the type for all numeric literals, i.e., there are no fixed-precision integers of type \haskell{Int}.
Decimal, hexadecimal and octal notation can be used.

\begin{table}[H]
  \begin{tabular}{l c r}
    \toprule[\heavyrulewidth]\toprule[\heavyrulewidth]
    \textbf{Name} & \textbf{Type} & \textbf{Constructors} \\
    \midrule
    unit     & \haskell{()} & \haskell{()} \\
    pairs    & \haskell{(@$\tau_1$@, @$\tau_2$@)} & \haskell{(,)} \\
    lists    & \haskell{[@$\tau$@]} & \haskell{[]} and \haskell{(:)} \\
    booleans & \haskell{Bool} & \haskell{True} and \haskell{False} \\
    integers & \haskell{Integer} &\\
    \bottomrule[\heavyrulewidth]
  \end{tabular}
  \caption{Predefined data types and their constructors.}
  \label{tbl:translation:assumtions:predefined}
\end{table}

The following commonly used operations for \haskell{Bool} and \haskell{Integer} are build into the compiler.
\begin{itemize}
  \item \textbf{Arithmetic operations:} addition \haskell{(+)}, subtraction \haskell{(-)}, multiplication \haskell{(*)}, exponentiation \haskell{(^)} and negation (using the \haskell{negate} function or unary minus operator).
  \item \textbf{Boolean operations:} conjunction \haskell{(&&)} and disjunction \haskell{(||)}
  \item \textbf{Comparison of integers:} \haskell{(<=)}, \haskell{(<)}, \haskell{(==)}, \haskell{(/=)}, \haskell{(>=)}, \haskell{(>)}
\end{itemize}
Floating point numbers, other literals such as \haskell{String}s and tuples with more than two elements are not supported yet.
