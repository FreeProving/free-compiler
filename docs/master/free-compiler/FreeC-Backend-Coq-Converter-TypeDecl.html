<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>FreeC.Backend.Coq.Converter.TypeDecl</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">free-compiler-0.1.0.0: A Haskell to Coq compiler.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">FreeC.Backend.Coq.Converter.TypeDecl</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains functions for converting type synonym and data type
   declarations and their constructors.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:convertTypeComponent">convertTypeComponent</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:sortTypeSynDecls">sortTypeSynDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>]</li><li class="src short"><a href="#v:fromNonRecursive">fromNonRecursive</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a></li><li class="src short"><a href="#v:isTypeSynDecl">isTypeSynDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:convertTypeSynDecl">convertTypeSynDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertDataDecls">convertDataDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence]</li><li class="src short"><a href="#v:convertDataDecl">convertDataDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> (IndBody, [Sentence])</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:convertTypeComponent" class="def">convertTypeComponent</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertTypeComponent" class="link">Source</a> <a href="#v:convertTypeComponent" class="selflink">#</a></p><div class="doc"><p>Converts a strongly connected component of the type dependency graph.</p></div></div><div class="top"><p class="src"><a id="v:sortTypeSynDecls" class="def">sortTypeSynDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#sortTypeSynDecls" class="link">Source</a> <a href="#v:sortTypeSynDecls" class="selflink">#</a></p><div class="doc"><p>Sorts type synonym declarations topologically.</p><p>After filtering type synonym declarations from the a strongly connected
   component, they are not mutually dependent on each other anymore (expect
   if they form a cycle). However, type synonyms may still depend on other
   type synonyms from the same strongly connected component. Therefore we
   have to sort the declarations in reverse topological order.</p></div></div><div class="top"><p class="src"><a id="v:fromNonRecursive" class="def">fromNonRecursive</a> :: <a href="FreeC-IR-DependencyGraph.html#t:DependencyComponent" title="FreeC.IR.DependencyGraph">DependencyComponent</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#fromNonRecursive" class="link">Source</a> <a href="#v:fromNonRecursive" class="selflink">#</a></p><div class="doc"><p>Extracts the single type synonym declaration from a strongly connected
   component of the type dependency graph.</p><p>Reports a fatal error if the component contains mutually recursive
   declarations (i.e. type synonyms form a cycle).</p></div></div><div class="top"><p class="src"><a id="v:isTypeSynDecl" class="def">isTypeSynDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#isTypeSynDecl" class="link">Source</a> <a href="#v:isTypeSynDecl" class="selflink">#</a></p><div class="doc"><p>Tests whether the given declaration is a type synonym declaration.</p></div></div><div class="top"><p class="src"><a id="v:convertTypeSynDecl" class="def">convertTypeSynDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertTypeSynDecl" class="link">Source</a> <a href="#v:convertTypeSynDecl" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell type synonym declaration to Coq.</p></div></div><div class="top"><p class="src"><a id="v:convertDataDecls" class="def">convertDataDecls</a> :: [<a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a>] -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> [Sentence] <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertDataDecls" class="link">Source</a> <a href="#v:convertDataDecls" class="selflink">#</a></p><div class="doc"><p>Converts multiple (mutually recursive) Haskell data type declaration
   declarations.</p><p>Before the declarations are actually translated, their identifiers are
   inserted into the current environment. Otherwise the data types would
   not be able to depend on each other. The identifiers for the constructors
   are inserted into the current environment as well. This makes the
   constructors more likely to keep their original name if there is a type
   variable with the same (lowercase) name.</p><p>After the <code>Inductive</code> sentences for the data type declarations there
   is one <code>Arguments</code> sentence and one smart constructor declaration for
   each constructor declaration of the given data types.</p></div></div><div class="top"><p class="src"><a id="v:convertDataDecl" class="def">convertDataDecl</a> :: <a href="FreeC-IR-Syntax-TypeDecl.html#t:TypeDecl" title="FreeC.IR.Syntax.TypeDecl">TypeDecl</a> -&gt; <a href="FreeC-Monad-Converter.html#t:Converter" title="FreeC.Monad.Converter">Converter</a> (IndBody, [Sentence]) <a href="src/FreeC.Backend.Coq.Converter.TypeDecl.html#convertDataDecl" class="link">Source</a> <a href="#v:convertDataDecl" class="selflink">#</a></p><div class="doc"><p>Converts a Haskell data type declaration to the body of a Coq <code>Inductive</code>
   sentence, the <code>Arguments</code> sentences for it's constructors and the smart
   constructor declarations.</p><p>Type variables declared by the data type or the smart constructors are
   not visible outside of this function.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>