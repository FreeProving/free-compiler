-- | This module contains the definition of a monad that is used by the
--   compiler to report error messages, warnings and hints to the user
--   without throwing an exception or performing IO actions.
--
--   During execution the 'Reporter' monad collects all reported messages
--   internally. Additionally the monad holds the result of the computation.
--   The computation can be interrupted without returning a result by reporting
--   a fatal error message.
--
--   This module also provides functions for pretty printing the collected
--   error messages in a similar way to how the GHC prints error messages.
--   Because this requires us to know the source code that corresponds to
--   line numbers there are functions to attach source code to the source
--   spans generated by the @haskell-src-exts@ parser (See 'SrcSpanConverter').

module Compiler.Reporter
  ( Message(..)
  , SrcSpan
  , Reporter
  , Severity(..)
  , SrcSpanConverter(..)
  , addMessages
  , foldReporter
  , isFatal
  , messages
  , putMessage
  , putMessages
  , hPutMessage
  , hPutMessages
  , report
  , reportFatal
  , reportIOErrors
  , reportIOError
  )
where

import           Control.Monad                  ( liftM
                                                , ap
                                                , join
                                                )
import           Data.Maybe                     ( maybe )
import qualified Data.Text.Lazy                as TL
import           Text.PrettyPrint.Leijen.Text
import           System.IO                      ( Handle
                                                , stdout
                                                )
import           System.IO.Error                ( catchIOError
                                                , ioeGetErrorString
                                                , ioeGetFileName
                                                )

import qualified Language.Haskell.Exts.SrcLoc  as H

-------------------------------------------------------------------------------
-- Messages                                                                  --
-------------------------------------------------------------------------------

-- | The severity of a message reported by the compiler.
data Severity = Error | Warning | Info

-- | A message reported by the compiler.
data Message = Message (Maybe SrcSpan) Severity String

-------------------------------------------------------------------------------
-- Source spans                                                              --
-------------------------------------------------------------------------------

-- | Describes the portion of the source code that caused a message to be
--   reported.
--
--   In contrast to the source spans provided by the @haskell-src-exts@ package
--   this source span provides access to the line of code that contains the
--   source span. This source span does not support source spans that span
--   multiple lines.
data SrcSpan = SrcSpan
  { filename    :: String
  , startLine   :: Int
  , startColumn :: Int
  , spanWidth   :: Int
  , codeLine    :: Maybe String
  }
  deriving (Show)

-- | Type class for @haskell-src-exts@ source spans that can be converted
--   to 'SrcSpan's for pretty printing of messages.
class SrcSpanConverter ss where
  -- | Converts a @haskell-src-exts@ source span to a 'SrcSpan' by
  --   attaching the corresponding line of source code.
  convertSrcSpan ::
    [(String, [String])] -- ^ A map of file names to lines of source code.
    -> ss                -- ^ The original source span to convert.
    -> SrcSpan

-- | Directly converts a 'H.SrcSpan' to a 'SrcSpan' by looking up
--   the corresponding line of code in the provided map.
instance SrcSpanConverter H.SrcSpan where
  convertSrcSpan codeByFilename srcSpan = SrcSpan
    { filename    = H.srcSpanFilename srcSpan
    , startLine   = H.srcSpanStartLine srcSpan
    , startColumn = H.srcSpanStartColumn srcSpan
    , spanWidth   = max 1 (snd (H.spanSize srcSpan))
    , codeLine    =
        lookup (H.srcSpanFilename srcSpan) codeByFilename
          >>= (nth (H.srcSpanStartLine srcSpan - 1))
    }
   where
    -- | Gets @n@-th element of a list or 'Nothing' if there is no such element.
    --
    -- TODO Create a module for utility functions like this?
    nth :: Int -> [a] -> Maybe a
    nth _ [] = Nothing
    nth n (x : xs) | n <= 0    = Just x
                   | otherwise = nth (n - 1) xs

-- | Converts a 'H.SrcSpanInfo' by removing additional information and applying
--   the conversion for 'H.SrcSpan's.
instance SrcSpanConverter H.SrcSpanInfo where
  convertSrcSpan codeByFilename = convertSrcSpan codeByFilename . H.srcInfoSpan

-- | Converts a 'H.SrcLoc' by creating a zero width source span and applying
--   the conversion for 'H.SrcSpan's.
instance SrcSpanConverter H.SrcLoc where
  convertSrcSpan codeByFilename = convertSrcSpan codeByFilename . join H.mkSrcSpan

-------------------------------------------------------------------------------
-- Reporter monad                                                            --
-------------------------------------------------------------------------------

-- | A data structure that contains the messages reported by the compiler
--   and an optional value that is present only if the compiler did not
--   encounter a fatal error.
--
--   The message lists are in reverse order, i.e. the last reported
--   message comes first. In case of 'Fatal' that mesan that the head
--   of the message list contains the reason for the failure.
data Reporter a =
  Report [Message] a
  | Fatal [Message]

-- | Functor instance for 'Reporter's to allow creation of the
--   'Applicative' instance.
instance Functor Reporter where
  fmap = liftM

-- | Applicative instance for 'Reporter's to allow creation of the
--   'Monad' instance.
instance Applicative Reporter where
  pure = return
  (<*>) = ap

-- | Monad instance for 'Reporter's.
--
--   When two reporters are executed in sequence, the resulting reporter
--   reports all messages of both reporters. The messages reported by the
--   second reporter will occur before.
--
--   When a reporter encounters a fatal error, no subsequent reporters are
--   executed.
instance Monad Reporter where
  return = Report []
  (>>=) (Report ms x) f = addMessages (f x) ms
  (>>=) (Fatal ms) _ = Fatal ms

-------------------------------------------------------------------------------
-- Reporting messages                                                        --
-------------------------------------------------------------------------------

-- | Appends a list of messages to the messages reported by the given reporter.
--
--   The new messages are added to the back of the message list.
addMessages :: Reporter a -> [Message] -> Reporter a
addMessages (Report ms x) ms' = Report (ms ++ ms') x
addMessages (Fatal ms   ) ms' = Fatal (ms ++ ms')

-- | Creates a successful reporter that reports the given message.
report :: Message -> Reporter ()
report msg = Report [msg] ()

-- | Creates a reporter that fails with the given message.
reportFatal :: Message -> Reporter a
reportFatal msg = Fatal [msg]

-- | Creates an IO action for a reporter that reports all IO errors that
--   that occur during the given IO action.
--
--   All IO errors are considered fatal and have no location information.
reportIOErrors :: IO (Reporter a) -> IO (Reporter a)
reportIOErrors action = catchIOError action (return . reportIOError)

-- | Reports the given IO error as a fatal error with no location information.
reportIOError :: IOError -> Reporter a
reportIOError = reportFatal . Message Nothing Error . ioErrorMessageText
 where
  ioErrorMessageText :: IOError -> String
  ioErrorMessageText err =
    ioeGetErrorString err ++ maybe "" (": " ++) (ioeGetFileName err)

-------------------------------------------------------------------------------
-- Handling messages and reporter results                                    --
-------------------------------------------------------------------------------

-- | Tests whether a fatal error was reported to the given reporter.
isFatal :: Reporter a -> Bool
isFatal (Report _ _) = False
isFatal (Fatal _   ) = True

-- | Gets the messages reported to the given reporter.
--
--   Because the reporter stores messages in reverse order (i.e. the head of
--   the stored list is the latest message) this function reverses the message
--   list such taht it is in the right order again (i.e. the head of the
--   returned list is the first message).
messages :: Reporter a -> [Message]
messages (Report ms _) = reverse ms
messages (Fatal ms   ) = reverse ms

-- | Handles the result of a reporter by invoking the given function or
--   returning the provided default value depending on whether a fatal
--   error was reported or not.
foldReporter
  :: Reporter a
  -> (a -> b)  -- ^ The function to apply if no fatal error was encountered.
  -> b         -- ^ The value to return if a fatal error was encountered.
  -> b
foldReporter (Report _ x) f _ = f x
foldReporter (Fatal _   ) _ v = v

-------------------------------------------------------------------------------
-- Printing messages                                                         --
-------------------------------------------------------------------------------

-- | Gets the label to print before the text of a message of the given
--   severity.
severityLabel :: Severity -> String
severityLabel Error   = "error"
severityLabel Warning = "warning"
severityLabel Info    = "info"

-- | Prints all given messages to @stdout@.
putMessages :: [Message] -> IO ()
putMessages = mapM_ putMessage

-- | Prints all given messages to the a file handle.
hPutMessages :: Handle -> [Message] -> IO ()
hPutMessages h = mapM_ (hPutMessage h)

-- | Prints the given message to @stdout@.
putMessage :: Message -> IO ()
putMessage = hPutMessage stdout

-- | Prints a message to the given file handle.
hPutMessage :: Handle -> Message -> IO ()
hPutMessage h = displayIO h . renderMessage

-- | Pretty prints and renders the given message with a maximum line length
--   of 80 characters.
renderMessage :: Message -> SimpleDoc
renderMessage = renderPretty ribbonFrac maxLineWidth . prettyMessage
 where
  -- | The maximum line width that must no be exceeded by the message text.
  --
  --   This is configured to be 80 characters, because on most platforms
  --   terminals have a default width of 80 columns.
  maxLineWidth :: Int
  maxLineWidth = 80

  -- | The whole line is allowed be occupied by non-indentation characters.
  ribbonFrac :: Float
  ribbonFrac = 1.0

-- | Pretty prints the given message.
prettyMessage :: Message -> Doc
prettyMessage (Message maybeSrcSpan severity msg) =
  maybeSrcSpanDoc <+> severityDoc <$$> msgDoc <> line <> maybeCodeDoc
 where
   -- | Document for the start of the source span or a placeholder text
   --   if there is no source span.
  maybeSrcSpanDoc :: Doc
  maybeSrcSpanDoc = maybe srcSpanPlaceholder srcSpanDoc maybeSrcSpan <> colon

  -- | The placeholder text to display if there is no source span.
  srcSpanPlaceholder :: Doc
  srcSpanPlaceholder = text (TL.pack "<no location info>")

  -- | Document for the start of the source span.
  srcSpanDoc :: SrcSpan -> Doc
  srcSpanDoc srcSpan =
    text (TL.pack (filename srcSpan))
      <> colon
      <> int (startLine srcSpan)
      <> colon
      <> int (startColumn srcSpan)

  -- | Document for the severity label with trailing colon.
  severityDoc :: Doc
  severityDoc = text (TL.pack (severityLabel severity)) <> colon

  -- | Document for the message text.
  --
  --   The message is indented by four spaces. The individual words of the
  --   messages are concatenated with 'softline's, such that the text is
  --   broken into multiple lines if it does not fit into a line of the
  --   configured 'width'.
  msgDoc :: Doc
  msgDoc = indent 4 (foldr (</>) empty (map (text . TL.pack) (words msg)))

  -- | Document that shows the line of code that caused the message to be
  --   reported if the message contains location information and the source
  --   code.
  maybeCodeDoc :: Doc
  maybeCodeDoc = maybe empty (uncurry codeDoc) $ do
    srcSpan <- maybeSrcSpan
    code    <- codeLine srcSpan
    return (srcSpan, code)

  -- | Document that displays the given line of code, the line number and
  --   highlights the source span using 'caret's.
  codeDoc :: SrcSpan -> String -> Doc
  codeDoc srcSpan code =
    gutterDoc srcSpan
      <$$> lineNumberDoc srcSpan
      <+>  text (TL.pack code)
      <$$> gutterDoc srcSpan
      <>   highlightDoc srcSpan
      <>   line

  -- | Document for the line number including padding and the trailing pipe.
  lineNumberDoc :: SrcSpan -> Doc
  lineNumberDoc srcSpan = space <> int (startLine srcSpan) <> space <> pipe

  -- | Document with the same length as 'lineNumberDoc' but without the line
  --   number.
  gutterDoc :: SrcSpan -> Doc
  gutterDoc srcSpan =
    let gutterWidth = length (show (startLine srcSpan)) + 2
    in  indent gutterWidth pipe

  -- | Document that contains 'caret' signs to highligh the source span.
  highlightDoc :: SrcSpan -> Doc
  highlightDoc srcSpan =
    indent (startColumn srcSpan) (hcat (replicate (spanWidth srcSpan) caret))

  -- | Document that contains the pipe character @|@.
  pipe :: Doc
  pipe = text (TL.pack "|")

  -- | Document that contains the caret character @^@.
  caret :: Doc
  caret = text (TL.pack "^")
